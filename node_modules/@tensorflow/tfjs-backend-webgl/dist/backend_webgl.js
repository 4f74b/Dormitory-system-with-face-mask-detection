/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Import webgl flags.
import './flags_webgl';
import { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, nextFrame, scalar, tidy, util } from '@tensorflow/tfjs-core';
import { getWebGLContext } from './canvas_util';
import { DecodeMatrixProgram } from './decode_matrix_gpu';
import { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';
import { EncodeFloatProgram } from './encode_float_gpu';
import { EncodeFloatPackedProgram } from './encode_float_packed_gpu';
import { EncodeMatrixProgram } from './encode_matrix_gpu';
import { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';
import { GPGPUContext } from './gpgpu_context';
import * as gpgpu_math from './gpgpu_math';
import { getUniformLocations } from './gpgpu_math';
import { simpleAbsImplCPU } from './kernel_utils/shared';
import { PackProgram } from './pack_gpu';
import { ReshapePackedProgram } from './reshape_packed_gpu';
import * as tex_util from './tex_util';
import { TextureUsage } from './tex_util';
import { TextureManager } from './texture_manager';
import * as unary_op from './unaryop_gpu';
import { UnaryOpProgram } from './unaryop_gpu';
import { UnaryOpPackedProgram } from './unaryop_packed_gpu';
import { UnpackProgram } from './unpack_gpu';
import * as webgl_util from './webgl_util';
const whereImpl = kernel_impls.whereImpl;
export const EPSILON_FLOAT32 = 1e-7;
export const EPSILON_FLOAT16 = 1e-4;
const binaryCaches = {};
export function getBinaryCache(webGLVersion) {
    if (webGLVersion in binaryCaches) {
        return binaryCaches[webGLVersion];
    }
    binaryCaches[webGLVersion] = {};
    return binaryCaches[webGLVersion];
}
// Empirically determined constant used to determine size threshold for handing
// off execution to the CPU.
const CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');
// Empirically determined constant used to decide the number of MB on GPU
// before we warn about high memory use. The MB are this constant * screen area
// * dpi / 1024 / 1024.
const BEFORE_PAGING_CONSTANT = 600;
function numMBBeforeWarning() {
    if (env().global.screen == null) {
        return 1024; // 1 GB.
    }
    return (env().global.screen.height * env().global.screen.width *
        window.devicePixelRatio) *
        BEFORE_PAGING_CONSTANT / 1024 / 1024;
}
export class MathBackendWebGL extends KernelBackend {
    constructor(gpuResource) {
        super();
        // Maps data ids that have a pending read operation, to list of subscribers.
        this.pendingRead = new WeakMap();
        // List of data ids that are scheduled for disposal, but are waiting on a
        // pending read operation.
        this.pendingDisposal = new WeakSet();
        // Used to count the number of 'shallow' sliced tensors that point to the
        // same data id.
        this.dataRefCount = new WeakMap();
        this.numBytesInGPU = 0;
        // Accumulated time spent (including blocking) in uploading data to webgl.
        this.uploadWaitMs = 0;
        // Accumulated time spent (including blocking in downloading data from webgl.
        this.downloadWaitMs = 0;
        // record the last manual GL Flush time.
        this.lastGlFlushTime = 0;
        this.warnedAboutMemory = false;
        this.pendingDeletes = 0;
        this.disposed = false;
        if (!env().getBool('HAS_WEBGL')) {
            throw new Error('WebGL is not supported on this device');
        }
        let newGPGPU;
        if (gpuResource != null) {
            if (gpuResource instanceof GPGPUContext) {
                newGPGPU = gpuResource;
            }
            else {
                const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'), gpuResource);
                newGPGPU = new GPGPUContext(gl);
            }
            this.binaryCache = {};
            this.gpgpuCreatedLocally = false;
        }
        else {
            const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));
            newGPGPU = new GPGPUContext(gl);
            this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));
            this.gpgpuCreatedLocally = true;
        }
        this.gpgpu = newGPGPU;
        this.canvas = this.gpgpu.gl.canvas;
        this.textureManager = new TextureManager(this.gpgpu);
        this.numMBBeforeWarning = numMBBeforeWarning();
        this.texData = new DataStorage(this, engine());
    }
    nextDataId() {
        return MathBackendWebGL.nextDataId++;
    }
    numDataIds() {
        return this.texData.numDataIds() - this.pendingDeletes;
    }
    // Writes a new entry to the data store with a WebGL texture, and registers it
    // to the texture manager.
    writeTexture(texture, shape, dtype, texHeight, texWidth, channels) {
        // Temporarily create an tensor info to make the texture compatible with
        // the runWebGLProgram's input.
        const input = this.makeTensorInfo(shape, dtype);
        const inData = this.texData.get(input.dataId);
        // Even though the input texture could be unpacked or dense packed, it is
        // always considered as unpacked for EncodeMatrixProgram.
        inData.isPacked = false;
        // Bind texture to the input tensor.
        inData.texture = { texture, texShape: [texHeight, texWidth] };
        inData.texShape = [texHeight, texWidth];
        const shapeAs3D = webgl_util.getShapeAs3D(shape);
        const program = new EncodeMatrixProgram(shapeAs3D, false /* isByteArray */, channels);
        const output = this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);
        output.shape = shape;
        // Unbind the texture from the input tensor to avoid the texture being
        // released.
        inData.texture = null;
        this.disposeIntermediateTensorInfo(input);
        return output.dataId;
    }
    write(values, shape, dtype) {
        if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||
            env().getBool('DEBUG')) {
            this.checkNumericalProblems(values);
        }
        if (dtype === 'complex64' && values != null) {
            throw new Error(`Cannot write to a complex64 dtype. ` +
                `Please use tf.complex(real, imag).`);
        }
        const dataId = { id: this.nextDataId() };
        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });
        return dataId;
    }
    /** Return refCount of a `TensorData`. */
    refCount(dataId) {
        if (this.texData.has(dataId)) {
            const tensorData = this.texData.get(dataId);
            return tensorData.refCount;
        }
        return 0;
    }
    /** Increase refCount of a `TextureData`. */
    incRef(dataId) {
        const texData = this.texData.get(dataId);
        texData.refCount++;
    }
    /** Decrease refCount of a `TextureData`. */
    decRef(dataId) {
        if (this.texData.has(dataId)) {
            const texData = this.texData.get(dataId);
            texData.refCount--;
        }
    }
    move(dataId, values, shape, dtype, refCount) {
        if (env().getBool('DEBUG')) {
            this.checkNumericalProblems(values);
        }
        if (dtype === 'complex64') {
            throw new Error(`Cannot write to a complex64 dtype. ` +
                `Please use tf.complex(real, imag).`);
        }
        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
        this.disposeData(tensorInfo.dataId);
    }
    readSync(dataId) {
        const texData = this.texData.get(dataId);
        const { values, dtype, complexTensorInfos, slice, shape, isPacked } = texData;
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) {
                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);
            }
            else {
                program = new UnaryOpProgram(shape, unary_op.CLONE);
            }
            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
            const data = this.readSync(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
        }
        if (values != null) {
            return this.convertAndCacheOnCPU(dataId);
        }
        if (dtype === 'string') {
            return values;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
            start = util.now();
        }
        let result;
        if (dtype === 'complex64') {
            const realValues = this.readSync(complexTensorInfos.real.dataId);
            const imagValues = this.readSync(complexTensorInfos.imag.dataId);
            result = backend_util.mergeRealAndImagArrays(realValues, imagValues);
        }
        else {
            result = this.getValuesFromTexture(dataId);
        }
        if (shouldTimeProgram) {
            this.downloadWaitMs += util.now() - start;
        }
        return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
        if (this.pendingRead.has(dataId)) {
            const subscribers = this.pendingRead.get(dataId);
            return new Promise(resolve => subscribers.push(resolve));
        }
        const texData = this.texData.get(dataId);
        const { values, shape, slice, dtype, complexTensorInfos, isPacked } = texData;
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) {
                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);
            }
            else {
                program = new UnaryOpProgram(shape, unary_op.CLONE);
            }
            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
            const data = this.read(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
        }
        if (values != null) {
            return this.convertAndCacheOnCPU(dataId);
        }
        if (env().getBool('DEBUG')) {
            // getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') caused a blocking GPU call.
            // For performance reason, only check it for debugging. In production,
            // it doesn't handle this use case anyway, so behavior is not changed.
            if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&
                env().getNumber('WEBGL_VERSION') === 2) {
                throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +
                    `WEBGL_VERSION=2 not yet supported.`);
            }
        }
        let buffer = null;
        let tmpDownloadTarget;
        if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {
            // Possibly copy the texture into a buffer before inserting a fence.
            tmpDownloadTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpDownloadTarget.dataId);
            buffer = this.gpgpu.createBufferFromTexture(tmpData.texture.texture, ...tex_util.getDenseTexShape(shape));
        }
        this.pendingRead.set(dataId, []);
        if (dtype !== 'complex64') {
            // Create a fence and wait for it to resolve.
            await this.gpgpu.createAndWaitForFence();
        }
        // Download the values from the GPU.
        let vals;
        if (dtype === 'complex64') {
            const ps = await Promise.all([
                this.read(complexTensorInfos.real.dataId),
                this.read(complexTensorInfos.imag.dataId)
            ]);
            const realValues = ps[0];
            const imagValues = ps[1];
            vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);
        }
        else if (buffer == null) {
            vals = this.getValuesFromTexture(dataId);
        }
        else {
            const size = util.sizeFromShape(shape);
            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);
        }
        if (tmpDownloadTarget != null) {
            this.disposeIntermediateTensorInfo(tmpDownloadTarget);
        }
        if (buffer != null) {
            const gl = this.gpgpu.gl;
            webgl_util.callAndCheck(gl, () => gl.deleteBuffer(buffer));
        }
        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
        const subscribers = this.pendingRead.get(dataId);
        this.pendingRead.delete(dataId);
        // Notify all pending reads.
        subscribers.forEach(resolve => resolve(dTypeVals));
        if (this.pendingDisposal.has(dataId)) {
            this.pendingDisposal.delete(dataId);
            if (this.disposeData(dataId)) {
                engine().removeDataId(dataId, this);
            }
            this.pendingDeletes--;
        }
        return dTypeVals;
    }
    /**
     * Read tensor to a new texture that is densely packed for ease of use.
     * @param dataId The source tensor.
     * @param options
     *     customTexShape: Optional. If set, will use the user defined texture
     *     shape to create the texture.
     */
    readToGPU(dataId, options = {}) {
        const texData = this.texData.get(dataId);
        const { values, shape, slice, dtype, isPacked, texture } = texData;
        if (dtype === 'complex64') {
            throw new Error('Does not support reading texture for complex64 dtype.');
        }
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) {
                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);
            }
            else {
                program = new UnaryOpProgram(shape, unary_op.CLONE);
            }
            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
            const gpuResouorce = this.readToGPU(res, options);
            this.disposeIntermediateTensorInfo(res);
            return gpuResouorce;
        }
        if (texture == null) {
            if (values != null) {
                throw new Error('Data is not on GPU but on CPU.');
            }
            else {
                throw new Error('There is no data on GPU or CPU.');
            }
        }
        // Decode the texture so that it is stored densely (using four channels).
        const tmpTarget = this.decode(dataId, options.customTexShape);
        // Make engine track this tensor, so that we can dispose it later.
        const tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);
        const tmpData = this.texData.get(tmpTarget.dataId);
        return Object.assign({ tensorRef }, tmpData.texture);
    }
    bufferSync(t) {
        const data = this.readSync(t.dataId);
        if (t.dtype === 'string') {
            try {
                // Decode the bytes into string.
                const strings = data.map(d => util.decodeString(d));
                return buffer(t.shape, t.dtype, strings);
            }
            catch (_a) {
                throw new Error('Failed to decode encoded string bytes into utf-8');
            }
        }
        return buffer(t.shape, t.dtype, data);
    }
    checkNumericalProblems(values) {
        if (values == null) {
            return;
        }
        for (let i = 0; i < values.length; i++) {
            const num = values[i];
            if (!webgl_util.canBeRepresented(num)) {
                if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {
                    throw Error(`The value ${num} cannot be represented with your ` +
                        `current settings. Consider enabling float32 rendering: ` +
                        `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
                }
                throw Error(`The value ${num} cannot be represented on this device.`);
            }
        }
    }
    getValuesFromTexture(dataId) {
        const { shape, dtype, isPacked } = this.texData.get(dataId);
        const size = util.sizeFromShape(shape);
        if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {
            const tmpTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpTarget.dataId);
            const vals = this.gpgpu
                .downloadMatrixFromPackedTexture(tmpData.texture.texture, ...tex_util.getDenseTexShape(shape))
                .subarray(0, size);
            this.disposeIntermediateTensorInfo(tmpTarget);
            return vals;
        }
        const shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;
        const outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;
        const program = shouldUsePackedProgram ?
            new EncodeFloatPackedProgram(outputShape) :
            new EncodeFloatProgram(outputShape);
        const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], 'float32');
        const tmpData = this.texData.get(output.dataId);
        const vals = this.gpgpu
            .downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1])
            .subarray(0, size);
        this.disposeIntermediateTensorInfo(output);
        return vals;
    }
    timerAvailable() {
        return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;
    }
    time(f) {
        const oldActiveTimers = this.activeTimers;
        const newActiveTimers = [];
        let outerMostTime = false;
        if (this.programTimersStack == null) {
            this.programTimersStack = newActiveTimers;
            outerMostTime = true;
        }
        else {
            this.activeTimers.push(newActiveTimers);
        }
        this.activeTimers = newActiveTimers;
        f();
        // needing to split these up because util.flatten only accepts certain types
        const flattenedActiveTimerQueries = util.flatten(this.activeTimers.map((d) => d.query))
            .filter(d => d != null);
        const flattenedActiveTimerNames = util.flatten(this.activeTimers.map((d) => d.name))
            .filter(d => d != null);
        this.activeTimers = oldActiveTimers;
        if (outerMostTime) {
            this.programTimersStack = null;
        }
        const res = {
            uploadWaitMs: this.uploadWaitMs,
            downloadWaitMs: this.downloadWaitMs,
            kernelMs: null,
            wallMs: null // will be filled by the engine
        };
        return (async () => {
            if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') >
                0) {
                const kernelMs = await Promise.all(flattenedActiveTimerQueries);
                res['kernelMs'] = util.sum(kernelMs);
                res['getExtraProfileInfo'] = () => kernelMs
                    .map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d }))
                    .map(d => `${d.name}: ${d.ms}`)
                    .join(', ');
            }
            else {
                res['kernelMs'] = {
                    error: 'WebGL query timers are not supported in this environment.'
                };
            }
            this.uploadWaitMs = 0;
            this.downloadWaitMs = 0;
            return res;
        })();
    }
    memory() {
        return {
            unreliable: false,
            numBytesInGPU: this.numBytesInGPU,
            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
            numBytesInGPUFree: this.textureManager.numBytesFree
        };
    }
    startTimer() {
        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            return this.gpgpu.beginQuery();
        }
        return { startMs: util.now(), endMs: null };
    }
    endTimer(query) {
        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = util.now();
        return query;
    }
    async getQueryTime(query) {
        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            return this.gpgpu.waitForQueryAndGetTime(query);
        }
        const timerQuery = query;
        return timerQuery.endMs - timerQuery.startMs;
    }
    /**
     * Decrease the RefCount on the dataId and dispose the memory if the dataId
     * has 0 refCount. If there are pending read on the data, the disposal would
     * added to the pending delete queue. Return true if the dataId is removed
     * from backend or the backend does not contain the dataId, false if the
     * dataId is not removed. Memory may or may not be released even when dataId
     * is removed, which also depends on dataRefCount, see `releaseGPU`.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */
    disposeData(dataId, force = false) {
        if (this.pendingDisposal.has(dataId)) {
            return false;
        }
        // No-op if already disposed.
        if (!this.texData.has(dataId)) {
            return true;
        }
        // if force flag is set, change refCount to 0, this would ensure disposal
        // when added to the pendingDisposal queue. Memory may or may not be
        // released, which also depends on dataRefCount, see `releaseGPU`.
        if (force) {
            this.texData.get(dataId).refCount = 0;
        }
        else {
            this.texData.get(dataId).refCount--;
        }
        if (!force && this.texData.get(dataId).refCount > 0) {
            return false;
        }
        if (this.pendingRead.has(dataId)) {
            this.pendingDisposal.add(dataId);
            this.pendingDeletes++;
            return false;
        }
        this.releaseGPUData(dataId);
        const { complexTensorInfos } = this.texData.get(dataId);
        if (complexTensorInfos != null) {
            this.disposeData(complexTensorInfos.real.dataId, force);
            this.disposeData(complexTensorInfos.imag.dataId, force);
        }
        this.texData.delete(dataId);
        return true;
    }
    releaseGPUData(dataId) {
        const { texture, dtype, texShape, usage, isPacked, slice } = this.texData.get(dataId);
        const key = slice && slice.origDataId || dataId;
        const refCount = this.dataRefCount.get(key);
        if (refCount > 1) {
            this.dataRefCount.set(key, refCount - 1);
        }
        else {
            this.dataRefCount.delete(key);
            if (texture != null) {
                this.numBytesInGPU -= this.computeBytes(texShape, dtype);
                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
            }
        }
        const texData = this.texData.get(dataId);
        texData.texture = null;
        texData.texShape = null;
        texData.isPacked = false;
        texData.slice = null;
    }
    getTexture(dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture.texture;
    }
    /**
     * Returns internal information for the specific data bucket. Used in unit
     * tests.
     */
    getDataInfo(dataId) {
        return this.texData.get(dataId);
    }
    /*
    Tests whether all the inputs to an op are small and on the CPU. This heuristic
    determines when it would be faster to execute a kernel on the CPU. WebGL
    kernels opt into running this check and forwarding when appropriate.
    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
    sustainable strategy for optimizing backend execution of ops.
     */
    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
        return env().getBool('WEBGL_CPU_FORWARD') &&
            inputs.every(input => this.texData.get(input.dataId).texture == null &&
                util.sizeFromShape(input.shape) < sizeThreshold);
    }
    getGPGPUContext() {
        return this.gpgpu;
    }
    where(condition) {
        backend_util.warn('tf.where() in webgl locks the UI thread. ' +
            'Call tf.whereAsync() instead');
        const condVals = condition.dataSync();
        return whereImpl(condition.shape, condVals);
    }
    packedUnaryOp(x, op, dtype) {
        const program = new UnaryOpPackedProgram(x.shape, op);
        const outInfo = this.compileAndRun(program, [x], dtype);
        return engine().makeTensorFromTensorInfo(outInfo);
    }
    // TODO(msoulanille) remove this once the backend has been modularized
    // a copy is needed here to break a circular dependency.
    // Also remove the op from unary_op.
    abs(x) {
        // TODO: handle cases when x is complex.
        if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {
            const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);
            return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {
            return this.packedUnaryOp(x, unary_op.ABS, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, unary_op.ABS);
        const outInfo = this.compileAndRun(program, [x]);
        return engine().makeTensorFromTensorInfo(outInfo);
    }
    makeTensorInfo(shape, dtype, values) {
        let dataId;
        if (dtype === 'string' && values != null && values.length > 0 &&
            util.isString(values[0])) {
            const encodedValues = values.map(d => util.encodeString(d));
            dataId = this.write(encodedValues, shape, dtype);
        }
        else {
            dataId = this.write(values, shape, dtype);
        }
        this.texData.get(dataId).usage = null;
        return { dataId, shape, dtype };
    }
    makeOutput(shape, dtype, values) {
        return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);
    }
    unpackTensor(input) {
        const program = new UnpackProgram(input.shape);
        return this.runWebGLProgram(program, [input], input.dtype);
    }
    packTensor(input) {
        const program = new PackProgram(input.shape);
        const preventEagerUnpackingOutput = true;
        return this.runWebGLProgram(program, [input], input.dtype, null /* customUniformValues */, preventEagerUnpackingOutput);
    }
    packedReshape(input, afterShape) {
        const input3DShape = [
            webgl_util.getBatchDim(input.shape),
            ...webgl_util.getRowsCols(input.shape)
        ];
        const input3D = {
            dtype: input.dtype,
            shape: input3DShape,
            dataId: input.dataId
        };
        const afterShapeAs3D = [
            webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)
        ];
        const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
        const preventEagerUnpackingOfOutput = true;
        const customValues = [input3DShape];
        const output = this.runWebGLProgram(program, [input3D], input.dtype, customValues, preventEagerUnpackingOfOutput);
        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
    decode(dataId, customTexShape) {
        const texData = this.texData.get(dataId);
        const { isPacked, shape, dtype } = texData;
        if (customTexShape != null) {
            const size = util.sizeFromShape(shape);
            const texSize = customTexShape[0] * customTexShape[1] * 4;
            util.assert(size <= texSize, () => 'customTexShape is too small. ' +
                'Row * Column * 4 should be equal or larger than the ' +
                'size of the tensor data.');
        }
        const shapeAs3D = webgl_util.getShapeAs3D(shape);
        let program;
        if (isPacked) {
            program = new DecodeMatrixPackedProgram(shapeAs3D);
        }
        else {
            program = new DecodeMatrixProgram(shapeAs3D);
        }
        const preventEagerUnpackingOfOutput = true;
        const customValues = [customTexShape != null ? customTexShape :
                tex_util.getDenseTexShape(shapeAs3D)];
        const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);
        return { dtype, shape, dataId: out.dataId };
    }
    runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false, customTexShape) {
        const output = this.makeTensorInfo(program.outputShape, outputDtype);
        const outData = this.texData.get(output.dataId);
        if (program.packedOutput) {
            outData.isPacked = true;
        }
        if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {
            const texelShape = customTexShape != null ?
                customTexShape :
                tex_util.getDenseTexShape(program.outputShape);
            // For a densely packed output, we explicitly set texShape
            // so it doesn't get assigned later according to our typical packing
            // scheme wherein a single texel can only contain values from adjacent
            // rows/cols.
            outData.texShape = texelShape.map(d => d * 2);
        }
        if (program.outTexUsage != null) {
            outData.usage = program.outTexUsage;
        }
        if (util.sizeFromShape(output.shape) === 0) {
            // Short-circuit the computation since the result is empty (has 0 in its
            // shape).
            outData.values =
                util.getTypedArrayFromDType(output.dtype, 0);
            return output;
        }
        const dataToDispose = [];
        const inputsData = inputs.map(input => {
            if (input.dtype === 'complex64') {
                throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` +
                    `dtypes, please separate the program into real and imaginary ` +
                    `parts.`);
            }
            let texData = this.texData.get(input.dataId);
            if (texData.texture == null) {
                if (!program.packedInputs &&
                    util.sizeFromShape(input.shape) <=
                        env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {
                    // Upload small tensors that live on the CPU as uniforms, not as
                    // textures. Do this only when the environment supports 32bit floats
                    // due to problems when comparing 16bit floats with 32bit floats.
                    // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it
                    // possible for packed shaders to sample from uniforms.
                    return {
                        shape: input.shape,
                        texData: null,
                        isUniform: true,
                        uniformValues: texData.values
                    };
                }
                // This ensures that if a packed program's inputs have not yet been
                // uploaded to the GPU, they get uploaded as packed right off the bat.
                if (program.packedInputs) {
                    texData.isPacked = true;
                    texData.shape = input.shape;
                }
            }
            this.uploadToGPU(input.dataId);
            if (!!texData.isPacked !== !!program.packedInputs) {
                input = texData.isPacked ? this.unpackTensor(input) :
                    this.packTensor(input);
                dataToDispose.push(input);
                texData = this.texData.get(input.dataId);
            }
            else if (texData.isPacked &&
                !webgl_util.isReshapeFree(texData.shape, input.shape)) {
                // This is a special case where a texture exists for a tensor
                // but the shapes are incompatible (due to packing constraints) because
                // the tensor did not have a chance to go through the packed reshape
                // shader. This only happens when we reshape the *same* tensor to form
                // *distinct* inputs to an op, e.g. dotting a vector with itself. This
                // case will disappear once packed uploading is the default.
                const savedInput = input;
                const targetShape = input.shape;
                input.shape = texData.shape;
                input = this.packedReshape(input, targetShape);
                dataToDispose.push(input);
                texData = this.texData.get(input.dataId);
                savedInput.shape = targetShape;
            }
            return { shape: input.shape, texData, isUniform: false };
        });
        this.uploadToGPU(output.dataId);
        const outputData = { shape: output.shape, texData: outData, isUniform: false };
        const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
        const binary = this.getAndSaveBinary(key, () => {
            return gpgpu_math.compileProgram(this.gpgpu, program, inputsData, outputData);
        });
        const shouldTimeProgram = this.activeTimers != null;
        let query;
        if (shouldTimeProgram) {
            query = this.startTimer();
        }
        if (!env().get('ENGINE_COMPILE_ONLY')) {
            gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);
        }
        dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
        }
        const glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');
        // Manually GL flush requested
        if (glFlushThreshold > 0) {
            const time = util.now();
            if ((time - this.lastGlFlushTime) > glFlushThreshold) {
                this.gpgpu.gl.flush();
                this.lastGlFlushTime = time;
            }
        }
        if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&
            preventEagerUnpackingOfOutput === false) {
            const unpacked = this.unpackTensor(output);
            this.disposeIntermediateTensorInfo(output);
            return unpacked;
        }
        return output;
    }
    compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
        outputDtype = outputDtype || inputs[0].dtype;
        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
        return outInfo;
    }
    getAndSaveBinary(key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    }
    getTextureManager() {
        return this.textureManager;
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        // Avoid disposing the compiled webgl programs during unit testing because
        // it slows down test execution.
        if (!env().getBool('IS_TEST')) {
            const allKeys = Object.keys(this.binaryCache);
            allKeys.forEach(key => {
                this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
                delete this.binaryCache[key];
            });
        }
        this.textureManager.dispose();
        if (this.canvas != null &&
            (typeof (HTMLCanvasElement) !== 'undefined' &&
                this.canvas instanceof HTMLCanvasElement)) {
            this.canvas.remove();
        }
        else {
            this.canvas = null;
        }
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.program = null;
            this.gpgpu.dispose();
        }
        this.disposed = true;
    }
    floatPrecision() {
        if (this.floatPrecisionValue == null) {
            this.floatPrecisionValue = tidy(() => {
                if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {
                    // Momentarily switching DEBUG flag to false so we don't throw an
                    // error trying to upload a small value.
                    const debugFlag = env().getBool('DEBUG');
                    env().set('DEBUG', false);
                    const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];
                    env().set('DEBUG', debugFlag);
                    if (underflowCheckValue > 0) {
                        return 32;
                    }
                }
                return 16;
            });
        }
        return this.floatPrecisionValue;
    }
    /** Returns the smallest representable number.  */
    epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
    }
    uploadToGPU(dataId) {
        const texData = this.texData.get(dataId);
        const { shape, dtype, values, texture, usage, isPacked } = texData;
        if (texture != null) {
            // Array is already on GPU. No-op.
            return;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
            start = util.now();
        }
        let texShape = texData.texShape;
        if (texShape == null) {
            // This texShape may not be the final texture shape. For packed or dense
            // textures, the texShape will be changed when textures are created.
            texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);
            texData.texShape = texShape;
        }
        if (values != null) {
            const shapeAs3D = webgl_util.getShapeAs3D(shape);
            let program;
            let width = texShape[1], height = texShape[0];
            const isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;
            // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we
            // need to make sure the upload uses the same packed size
            if (isPacked || !isByteArray) {
                [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
            }
            if (isPacked) {
                program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);
            }
            else {
                program = new EncodeMatrixProgram(shapeAs3D, isByteArray);
            }
            // TexShape for float array needs to be the original shape, which byte
            // array needs to be packed size. This allow the data upload shape to be
            // matched with texture creation logic.
            const tempDenseInputTexShape = isByteArray ? [height, width] : texShape;
            const tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);
            const tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);
            if (isByteArray) {
                tempDenseInputTexData.usage = TextureUsage.PIXELS;
            }
            else {
                tempDenseInputTexData.usage = TextureUsage.UPLOAD;
            }
            tempDenseInputTexData.texShape = tempDenseInputTexShape;
            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
            const customValues = [[height, width]];
            // We want the output to remain packed regardless of the value of
            // WEBGL_PACK.
            const preventEagerUnpacking = true;
            const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);
            // Have the original texture assume the identity of the encoded output.
            const outputTexData = this.texData.get(encodedOutputTarget.dataId);
            texData.texShape = outputTexData.texShape;
            texData.isPacked = outputTexData.isPacked;
            texData.usage = outputTexData.usage;
            if (!env().get('ENGINE_COMPILE_ONLY')) {
                texData.texture = outputTexData.texture;
                // Once uploaded, don't store the values on cpu.
                texData.values = null;
                this.texData.delete(encodedOutputTarget.dataId);
            }
            else {
                this.disposeData(encodedOutputTarget.dataId);
            }
            this.disposeIntermediateTensorInfo(tempDenseInputHandle);
            if (shouldTimeProgram) {
                this.uploadWaitMs += util.now() - start;
            }
        }
        else {
            const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
            texData.texture = newTexture;
        }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
        const texData = this.texData.get(dataId);
        const { dtype } = texData;
        if (float32Values != null) {
            texData.values = float32ToTypedArray(float32Values, dtype);
        }
        return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
        this.numBytesInGPU += this.computeBytes(texShape, dtype);
        if (!this.warnedAboutMemory &&
            this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
            const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
            this.warnedAboutMemory = true;
            console.warn(`High memory usage in GPU: ${mb} MB, ` +
                `most likely due to a memory leak`);
        }
        return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
        return shape[0] * shape[1] * util.bytesPerElement(dtype);
    }
    checkCompileCompletion() {
        for (const [, binary] of Object.entries(this.binaryCache)) {
            this.checkCompletion_(binary);
        }
    }
    async checkCompileCompletionAsync() {
        const ps = [];
        if (this.gpgpu.parallelCompilationExtension) {
            for (const [, binary] of Object.entries(this.binaryCache)) {
                ps.push(this.checkCompletionAsync_(binary));
            }
            return Promise.all(ps);
        }
        else {
            for (const [, binary] of Object.entries(this.binaryCache)) {
                const p = new Promise((resolve) => {
                    try {
                        this.checkCompletion_(binary);
                        resolve(true);
                    }
                    catch (error) {
                        throw error;
                    }
                });
                ps.push(p);
            }
            return Promise.all(ps);
        }
    }
    async checkCompletionAsync_(binary) {
        if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
            return this.checkCompletion_(binary);
        }
        else {
            await nextFrame();
            return this.checkCompletionAsync_(binary);
        }
    }
    checkCompletion_(binary) {
        if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {
            console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));
            if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {
                webgl_util.logShaderSourceAndInfoLog(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));
                throw new Error('Failed to compile fragment shader.');
            }
            throw new Error('Failed to link vertex and fragment shaders.');
        }
        return true;
    }
    getUniformLocations() {
        for (const [, binary] of Object.entries(this.binaryCache)) {
            const { uniformLocations, customUniformLocations, infLoc, nanLoc, inShapesLocations, inTexShapesLocations, outShapeLocation, outShapeStridesLocation, outTexShapeLocation } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);
            binary.uniformLocations = uniformLocations;
            binary.customUniformLocations = customUniformLocations;
            binary.infLoc = infLoc;
            binary.nanLoc = nanLoc;
            binary.inShapesLocations = inShapesLocations;
            binary.inTexShapesLocations = inTexShapesLocations;
            binary.outShapeLocation = outShapeLocation;
            binary.outShapeStridesLocation = outShapeStridesLocation;
            binary.outTexShapeLocation = outTexShapeLocation;
        }
    }
    /**
     * Create a TF.js tensor out of an existing WebGL texture. A new texture will
     * be created.
     */
    createTensorFromTexture(values, shape, dtype) {
        const { texture, height, width, channels } = values;
        const backend = engine().backend;
        // Have to throw an error, otherwise WebGL just warns and returns wrong
        // values.
        if (!backend.gpgpu.gl.isTexture(texture)) {
            throw new Error(`The texture is invalid. Also, please make sure the texture and ` +
                `the TFJS WebGL backend are using the same canvas. If you want to ` +
                `use your own custom canvas, you have to create and use the custom ` +
                `TFJS WebGL backend created from the canvas through ` +
                `'new tf.MathBackendWebGL(customCanvas)'.`);
        }
        const dataId = backend.writeTexture(texture, shape, dtype, height, width, channels);
        return engine().makeTensorFromDataId(dataId, shape, dtype, backend);
    }
}
MathBackendWebGL.nextDataId = 0;
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32' || dtype === 'complex64') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        const result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (let i = 0; i < result.length; ++i) {
            result[i] = Math.round(a[i]);
        }
        return result;
    }
    else {
        throw new Error(`Unknown dtype ${dtype}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF93ZWJnbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvYmFja2VuZF93ZWJnbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxzQkFBc0I7QUFDdEIsT0FBTyxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFDLFlBQVksRUFBaUIsTUFBTSxFQUFVLFdBQVcsRUFBa0MsTUFBTSxFQUFFLEdBQUcsRUFBVyxZQUFZLEVBQUUsYUFBYSxFQUFjLFNBQVMsRUFBeUMsTUFBTSxFQUF3RCxJQUFJLEVBQTBCLElBQUksRUFBWSxNQUFNLHVCQUF1QixDQUFDO0FBQzdWLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDOUMsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDeEQsT0FBTyxFQUFDLHlCQUF5QixFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDckUsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDdEQsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDbkUsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDeEQsT0FBTyxFQUFDLHlCQUF5QixFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDckUsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sS0FBSyxVQUFVLE1BQU0sY0FBYyxDQUFDO0FBQzNDLE9BQU8sRUFBQyxtQkFBbUIsRUFBd0MsTUFBTSxjQUFjLENBQUM7QUFDeEYsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUN2QyxPQUFPLEVBQUMsb0JBQW9CLEVBQUMs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Qy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBJbXBvcnQgd2ViZ2wgZmxhZ3MuXG5pbXBvcnQgJy4vZmxhZ3Nfd2ViZ2wnO1xuXG5pbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIEJhY2tlbmRWYWx1ZXMsIGJ1ZmZlciwgRGF0YUlkLCBEYXRhU3RvcmFnZSwgRGF0YVRvR1BVV2ViR0xPcHRpb24sIERhdGFUeXBlLCBlbmdpbmUsIGVudiwgR1BVRGF0YSwga2VybmVsX2ltcGxzLCBLZXJuZWxCYWNrZW5kLCBNZW1vcnlJbmZvLCBuZXh0RnJhbWUsIE51bWVyaWNEYXRhVHlwZSwgUmFuaywgUmVjdXJzaXZlQXJyYXksIHNjYWxhciwgU2hhcGVNYXAsIFRlbnNvciwgVGVuc29yMkQsIFRlbnNvckJ1ZmZlciwgVGVuc29ySW5mbywgdGlkeSwgVGltaW5nSW5mbywgVHlwZWRBcnJheSwgdXRpbCwgV2ViR0xEYXRhfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtnZXRXZWJHTENvbnRleHR9IGZyb20gJy4vY2FudmFzX3V0aWwnO1xuaW1wb3J0IHtEZWNvZGVNYXRyaXhQcm9ncmFtfSBmcm9tICcuL2RlY29kZV9tYXRyaXhfZ3B1JztcbmltcG9ydCB7RGVjb2RlTWF0cml4UGFja2VkUHJvZ3JhbX0gZnJvbSAnLi9kZWNvZGVfbWF0cml4X3BhY2tlZF9ncHUnO1xuaW1wb3J0IHtFbmNvZGVGbG9hdFByb2dyYW19IGZyb20gJy4vZW5jb2RlX2Zsb2F0X2dwdSc7XG5pbXBvcnQge0VuY29kZUZsb2F0UGFja2VkUHJvZ3JhbX0gZnJvbSAnLi9lbmNvZGVfZmxvYXRfcGFja2VkX2dwdSc7XG5pbXBvcnQge0VuY29kZU1hdHJpeFByb2dyYW19IGZyb20gJy4vZW5jb2RlX21hdHJpeF9ncHUnO1xuaW1wb3J0IHtFbmNvZGVNYXRyaXhQYWNrZWRQcm9ncmFtfSBmcm9tICcuL2VuY29kZV9tYXRyaXhfcGFja2VkX2dwdSc7XG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcbmltcG9ydCAqIGFzIGdwZ3B1X21hdGggZnJvbSAnLi9ncGdwdV9tYXRoJztcbmltcG9ydCB7Z2V0VW5pZm9ybUxvY2F0aW9ucywgR1BHUFVCaW5hcnksIEdQR1BVUHJvZ3JhbSwgVGVuc29yRGF0YX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcbmltcG9ydCB7c2ltcGxlQWJzSW1wbENQVX0gZnJvbSAnLi9rZXJuZWxfdXRpbHMvc2hhcmVkJztcbmltcG9ydCB7UGFja1Byb2dyYW19IGZyb20gJy4vcGFja19ncHUnO1xuaW1wb3J0IHtSZXNoYXBlUGFja2VkUHJvZ3JhbX0gZnJvbSAnLi9yZXNoYXBlX3BhY2tlZF9ncHUnO1xuaW1wb3J0ICogYXMgdGV4X3V0aWwgZnJvbSAnLi90ZXhfdXRpbCc7XG5pbXBvcnQge1RleHR1cmUsIFRleHR1cmVEYXRhLCBUZXh0dXJlVXNhZ2V9IGZyb20gJy4vdGV4X3V0aWwnO1xuaW1wb3J0IHtUZXh0dXJlTWFuYWdlcn0gZnJvbSAnLi90ZXh0dXJlX21hbmFnZXInO1xuaW1wb3J0ICogYXMgdW5hcnlfb3AgZnJvbSAnLi91bmFyeW9wX2dwdSc7XG5pbXBvcnQge1VuYXJ5T3BQcm9ncmFtfSBmcm9tICcuL3VuYXJ5b3BfZ3B1JztcbmltcG9ydCB7VW5hcnlPcFBhY2tlZFByb2dyYW19IGZyb20gJy4vdW5hcnlvcF9wYWNrZWRfZ3B1JztcbmltcG9ydCB7VW5wYWNrUHJvZ3JhbX0gZnJvbSAnLi91bnBhY2tfZ3B1JztcbmltcG9ydCAqIGFzIHdlYmdsX3V0aWwgZnJvbSAnLi93ZWJnbF91dGlsJztcblxuY29uc3Qgd2hlcmVJbXBsID0ga2VybmVsX2ltcGxzLndoZXJlSW1wbDtcblxuZXhwb3J0IGNvbnN0IEVQU0lMT05fRkxPQVQzMiA9IDFlLTc7XG5leHBvcnQgY29uc3QgRVBTSUxPTl9GTE9BVDE2ID0gMWUtNDtcblxudHlwZSBLZXJuZWxJbmZvID0ge1xuICBuYW1lOiBzdHJpbmc7IHF1ZXJ5OiBQcm9taXNlPG51bWJlcj47XG59O1xuXG5leHBvcnQgdHlwZSBUaW1lck5vZGUgPSBSZWN1cnNpdmVBcnJheTxLZXJuZWxJbmZvPnxLZXJuZWxJbmZvO1xuZXhwb3J0IGludGVyZmFjZSBDUFVUaW1lclF1ZXJ5IHtcbiAgc3RhcnRNczogbnVtYmVyO1xuICBlbmRNcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWJHTE1lbW9yeUluZm8gZXh0ZW5kcyBNZW1vcnlJbmZvIHtcbiAgbnVtQnl0ZXNJbkdQVTogbnVtYmVyO1xuICAvLyBUcmFja3MgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBhbGxvY2F0ZWQgb24gdGhlIEdQVSwgYWNjb3VudGluZyBmb3IgdGhlXG4gIC8vIHBoeXNpY2FsIHRleHR1cmUgdHlwZS5cbiAgbnVtQnl0ZXNJbkdQVUFsbG9jYXRlZDogbnVtYmVyO1xuICAvLyBUcmFja3MgYnl0ZSBzaXplIG9mIHRleHR1cmVzIHRoYXQgd2VyZSBjcmVhdGVkIGFuZCB0aGVuIG1hZGUgYXZhaWxhYmxlIGZvclxuICAvLyByZXVzZSAoZGlzcG9zZWQpLlxuICBudW1CeXRlc0luR1BVRnJlZTogbnVtYmVyO1xuICB1bnJlbGlhYmxlOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlYkdMVGltaW5nSW5mbyBleHRlbmRzIFRpbWluZ0luZm8ge1xuICB1cGxvYWRXYWl0TXM6IG51bWJlcjtcbiAgZG93bmxvYWRXYWl0TXM6IG51bWJlcjtcbn1cblxuY29uc3QgYmluYXJ5Q2FjaGVzOiB7W3dlYkdMVmVyc2lvbjogc3RyaW5nXToge1trZXk6IHN0cmluZ106IEdQR1BVQmluYXJ5fX0gPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJpbmFyeUNhY2hlKHdlYkdMVmVyc2lvbjogbnVtYmVyKSB7XG4gIGlmICh3ZWJHTFZlcnNpb24gaW4gYmluYXJ5Q2FjaGVzKSB7XG4gICAgcmV0dXJuIGJpbmFyeUNhY2hlc1t3ZWJHTFZlcnNpb25dO1xuICB9XG4gIGJpbmFyeUNhY2hlc1t3ZWJHTFZlcnNpb25dID0ge307XG4gIHJldHVybiBiaW5hcnlDYWNoZXNbd2ViR0xWZXJzaW9uXTtcbn1cblxuLy8gRW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBjb25zdGFudCB1c2VkIHRvIGRldGVybWluZSBzaXplIHRocmVzaG9sZCBmb3IgaGFuZGluZ1xuLy8gb2ZmIGV4ZWN1dGlvbiB0byB0aGUgQ1BVLlxuY29uc3QgQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTEQgPVxuICAgIGVudigpLmdldE51bWJlcignQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTEQnKTtcblxuLy8gRW1waXJpY2FsbHkgZGV0ZXJtaW5lZCBjb25zdGFudCB1c2VkIHRvIGRlY2lkZSB0aGUgbnVtYmVyIG9mIE1CIG9uIEdQVVxuLy8gYmVmb3JlIHdlIHdhcm4gYWJvdXQgaGlnaCBtZW1vcnkgdXNlLiBUaGUgTUIgYXJlIHRoaXMgY29uc3RhbnQgKiBzY3JlZW4gYXJlYVxuLy8gKiBkcGkgLyAxMDI0IC8gMTAyNC5cbmNvbnN0IEJFRk9SRV9QQUdJTkdfQ09OU1RBTlQgPSA2MDA7XG5mdW5jdGlvbiBudW1NQkJlZm9yZVdhcm5pbmcoKTogbnVtYmVyIHtcbiAgaWYgKGVudigpLmdsb2JhbC5zY3JlZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAxMDI0OyAgLy8gMSBHQi5cbiAgfVxuICByZXR1cm4gKGVudigpLmdsb2JhbC5zY3JlZW4uaGVpZ2h0ICogZW52KCkuZ2xvYmFsLnNjcmVlbi53aWR0aCAqXG4gICAgICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8pICpcbiAgICAgIEJFRk9SRV9QQUdJTkdfQ09OU1RBTlQgLyAxMDI0IC8gMTAyNDtcbn1cblxuZXhwb3J0IGNsYXNzIE1hdGhCYWNrZW5kV2ViR0wgZXh0ZW5kcyBLZXJuZWxCYWNrZW5kIHtcbiAgdGV4RGF0YTogRGF0YVN0b3JhZ2U8VGV4dHVyZURhdGE+O1xuICBncGdwdTogR1BHUFVDb250ZXh0O1xuXG4gIHByaXZhdGUgc3RhdGljIG5leHREYXRhSWQgPSAwO1xuICBwcml2YXRlIG5leHREYXRhSWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRXZWJHTC5uZXh0RGF0YUlkKys7XG4gIH1cbiAgLy8gTWFwcyBkYXRhIGlkcyB0aGF0IGhhdmUgYSBwZW5kaW5nIHJlYWQgb3BlcmF0aW9uLCB0byBsaXN0IG9mIHN1YnNjcmliZXJzLlxuICBwcml2YXRlIHBlbmRpbmdSZWFkID0gbmV3IFdlYWtNYXA8RGF0YUlkLCBBcnJheTwoYXJyOiBUeXBlZEFycmF5KSA9PiB2b2lkPj4oKTtcbiAgLy8gTGlzdCBvZiBkYXRhIGlkcyB0aGF0IGFyZSBzY2hlZHVsZWQgZm9yIGRpc3Bvc2FsLCBidXQgYXJlIHdhaXRpbmcgb24gYVxuICAvLyBwZW5kaW5nIHJlYWQgb3BlcmF0aW9uLlxuICBwcml2YXRlIHBlbmRpbmdEaXNwb3NhbCA9IG5ldyBXZWFrU2V0PERhdGFJZD4oKTtcblxuICAvLyBVc2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgJ3NoYWxsb3cnIHNsaWNlZCB0ZW5zb3JzIHRoYXQgcG9pbnQgdG8gdGhlXG4gIC8vIHNhbWUgZGF0YSBpZC5cbiAgZGF0YVJlZkNvdW50ID0gbmV3IFdlYWtNYXA8RGF0YUlkLCBudW1iZXI+KCk7XG4gIHByaXZhdGUgbnVtQnl0ZXNJbkdQVSA9IDA7XG5cbiAgcHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhcztcblxuICBwcml2YXRlIHByb2dyYW1UaW1lcnNTdGFjazogVGltZXJOb2RlW107XG4gIHByaXZhdGUgYWN0aXZlVGltZXJzOiBUaW1lck5vZGVbXTtcbiAgLy8gQWNjdW11bGF0ZWQgdGltZSBzcGVudCAoaW5jbHVkaW5nIGJsb2NraW5nKSBpbiB1cGxvYWRpbmcgZGF0YSB0byB3ZWJnbC5cbiAgcHJpdmF0ZSB1cGxvYWRXYWl0TXMgPSAwO1xuICAvLyBBY2N1bXVsYXRlZCB0aW1lIHNwZW50IChpbmNsdWRpbmcgYmxvY2tpbmcgaW4gZG93bmxvYWRpbmcgZGF0YSBmcm9tIHdlYmdsLlxuICBwcml2YXRlIGRvd25sb2FkV2FpdE1zID0gMDtcblxuICAvLyByZWNvcmQgdGhlIGxhc3QgbWFudWFsIEdMIEZsdXNoIHRpbWUuXG4gIHByaXZhdGUgbGFzdEdsRmx1c2hUaW1lID0gMDtcblxuICAvLyBOdW1iZXIgb2YgYml0cyBvZiBwcmVjaXNpb24gb2YgdGhpcyBiYWNrZW5kLlxuICBwcml2YXRlIGZsb2F0UHJlY2lzaW9uVmFsdWU6IDMyfDE2O1xuXG4gIHByaXZhdGUgdGV4dHVyZU1hbmFnZXI6IFRleHR1cmVNYW5hZ2VyO1xuICBwcml2YXRlIGJpbmFyeUNhY2hlOiB7W2tleTogc3RyaW5nXTogR1BHUFVCaW5hcnl9O1xuICBwcml2YXRlIGdwZ3B1Q3JlYXRlZExvY2FsbHk6IGJvb2xlYW47XG4gIHByaXZhdGUgbnVtTUJCZWZvcmVXYXJuaW5nOiBudW1iZXI7XG4gIHByaXZhdGUgd2FybmVkQWJvdXRNZW1vcnkgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihncHVSZXNvdXJjZT86IEdQR1BVQ29udGV4dHxIVE1MQ2FudmFzRWxlbWVudHxPZmZzY3JlZW5DYW52YXMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghZW52KCkuZ2V0Qm9vbCgnSEFTX1dFQkdMJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgIH1cblxuICAgIGxldCBuZXdHUEdQVTtcbiAgICBpZiAoZ3B1UmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgaWYgKGdwdVJlc291cmNlIGluc3RhbmNlb2YgR1BHUFVDb250ZXh0KSB7XG4gICAgICAgIG5ld0dQR1BVID0gZ3B1UmVzb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBnbCA9XG4gICAgICAgICAgICBnZXRXZWJHTENvbnRleHQoZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9WRVJTSU9OJyksIGdwdVJlc291cmNlKTtcbiAgICAgICAgbmV3R1BHUFUgPSBuZXcgR1BHUFVDb250ZXh0KGdsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmluYXJ5Q2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBnbCA9IGdldFdlYkdMQ29udGV4dChlbnYoKS5nZXROdW1iZXIoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICBuZXdHUEdQVSA9IG5ldyBHUEdQVUNvbnRleHQoZ2wpO1xuICAgICAgdGhpcy5iaW5hcnlDYWNoZSA9IGdldEJpbmFyeUNhY2hlKGVudigpLmdldE51bWJlcignV0VCR0xfVkVSU0lPTicpKTtcbiAgICAgIHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5ncGdwdSA9IG5ld0dQR1BVO1xuICAgIHRoaXMuY2FudmFzID0gdGhpcy5ncGdwdS5nbC5jYW52YXM7XG4gICAgdGhpcy50ZXh0dXJlTWFuYWdlciA9IG5ldyBUZXh0dXJlTWFuYWdlcih0aGlzLmdwZ3B1KTtcbiAgICB0aGlzLm51bU1CQmVmb3JlV2FybmluZyA9IG51bU1CQmVmb3JlV2FybmluZygpO1xuICAgIHRoaXMudGV4RGF0YSA9IG5ldyBEYXRhU3RvcmFnZSh0aGlzLCBlbmdpbmUoKSk7XG4gIH1cblxuICBvdmVycmlkZSBudW1EYXRhSWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRleERhdGEubnVtRGF0YUlkcygpIC0gdGhpcy5wZW5kaW5nRGVsZXRlcztcbiAgfVxuXG4gIC8vIFdyaXRlcyBhIG5ldyBlbnRyeSB0byB0aGUgZGF0YSBzdG9yZSB3aXRoIGEgV2ViR0wgdGV4dHVyZSwgYW5kIHJlZ2lzdGVycyBpdFxuICAvLyB0byB0aGUgdGV4dHVyZSBtYW5hZ2VyLlxuICB3cml0ZVRleHR1cmUoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHNoYXBlOiBudW1iZXJbXSwgZHR5cGU6IERhdGFUeXBlLFxuICAgICAgdGV4SGVpZ2h0OiBudW1iZXIsIHRleFdpZHRoOiBudW1iZXIsIGNoYW5uZWxzOiBzdHJpbmcpOiBEYXRhSWQge1xuICAgIC8vIFRlbXBvcmFyaWx5IGNyZWF0ZSBhbiB0ZW5zb3IgaW5mbyB0byBtYWtlIHRoZSB0ZXh0dXJlIGNvbXBhdGlibGUgd2l0aFxuICAgIC8vIHRoZSBydW5XZWJHTFByb2dyYW0ncyBpbnB1dC5cbiAgICBjb25zdCBpbnB1dCA9IHRoaXMubWFrZVRlbnNvckluZm8oc2hhcGUsIGR0eXBlKTtcbiAgICBjb25zdCBpbkRhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGlucHV0LmRhdGFJZCk7XG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlIGlucHV0IHRleHR1cmUgY291bGQgYmUgdW5wYWNrZWQgb3IgZGVuc2UgcGFja2VkLCBpdCBpc1xuICAgIC8vIGFsd2F5cyBjb25zaWRlcmVkIGFzIHVucGFja2VkIGZvciBFbmNvZGVNYXRyaXhQcm9ncmFtLlxuICAgIGluRGF0YS5pc1BhY2tlZCA9IGZhbHNlO1xuXG4gICAgLy8gQmluZCB0ZXh0dXJlIHRvIHRoZSBpbnB1dCB0ZW5zb3IuXG4gICAgaW5EYXRhLnRleHR1cmUgPSB7dGV4dHVyZSwgdGV4U2hhcGU6IFt0ZXhIZWlnaHQsIHRleFdpZHRoXX07XG4gICAgaW5EYXRhLnRleFNoYXBlID0gW3RleEhlaWdodCwgdGV4V2lkdGhdO1xuXG4gICAgY29uc3Qgc2hhcGVBczNEID0gd2ViZ2xfdXRpbC5nZXRTaGFwZUFzM0Qoc2hhcGUpO1xuICAgIGNvbnN0IHByb2dyYW0gPVxuICAgICAgICBuZXcgRW5jb2RlTWF0cml4UHJvZ3JhbShzaGFwZUFzM0QsIGZhbHNlIC8qIGlzQnl0ZUFycmF5ICovLCBjaGFubmVscyk7XG4gICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgICAgdGhpcy5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2lucHV0XSwgZHR5cGUsIFtbdGV4SGVpZ2h0LCB0ZXhXaWR0aF1dKTtcbiAgICBvdXRwdXQuc2hhcGUgPSBzaGFwZTtcblxuICAgIC8vIFVuYmluZCB0aGUgdGV4dHVyZSBmcm9tIHRoZSBpbnB1dCB0ZW5zb3IgdG8gYXZvaWQgdGhlIHRleHR1cmUgYmVpbmdcbiAgICAvLyByZWxlYXNlZC5cbiAgICBpbkRhdGEudGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpbnB1dCk7XG5cbiAgICByZXR1cm4gb3V0cHV0LmRhdGFJZDtcbiAgfVxuXG4gIG92ZXJyaWRlIHdyaXRlKHZhbHVlczogQmFja2VuZFZhbHVlcywgc2hhcGU6IG51bWJlcltdLCBkdHlwZTogRGF0YVR5cGUpOlxuICAgICAgRGF0YUlkIHtcbiAgICBpZiAoZW52KCkuZ2V0Qm9vbCgnV0VCR0xfQ0hFQ0tfTlVNRVJJQ0FMX1BST0JMRU1TJykgfHxcbiAgICAgICAgZW52KCkuZ2V0Qm9vbCgnREVCVUcnKSkge1xuICAgICAgdGhpcy5jaGVja051bWVyaWNhbFByb2JsZW1zKHZhbHVlcyk7XG4gICAgfVxuICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcgJiYgdmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBgICtcbiAgICAgICAgICBgUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLmApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhSWQgPSB7aWQ6IHRoaXMubmV4dERhdGFJZCgpfTtcbiAgICB0aGlzLnRleERhdGEuc2V0KFxuICAgICAgICBkYXRhSWQsXG4gICAgICAgIHtzaGFwZSwgZHR5cGUsIHZhbHVlcywgdXNhZ2U6IFRleHR1cmVVc2FnZS5VUExPQUQsIHJlZkNvdW50OiAxfSk7XG4gICAgcmV0dXJuIGRhdGFJZDtcbiAgfVxuXG4gIC8qKiBSZXR1cm4gcmVmQ291bnQgb2YgYSBgVGVuc29yRGF0YWAuICovXG4gIG92ZXJyaWRlIHJlZkNvdW50KGRhdGFJZDogRGF0YUlkKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy50ZXhEYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICBjb25zdCB0ZW5zb3JEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgcmV0dXJuIHRlbnNvckRhdGEucmVmQ291bnQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqIEluY3JlYXNlIHJlZkNvdW50IG9mIGEgYFRleHR1cmVEYXRhYC4gKi9cbiAgb3ZlcnJpZGUgaW5jUmVmKGRhdGFJZDogRGF0YUlkKTogdm9pZCB7XG4gICAgY29uc3QgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICB0ZXhEYXRhLnJlZkNvdW50Kys7XG4gIH1cblxuICAvKiogRGVjcmVhc2UgcmVmQ291bnQgb2YgYSBgVGV4dHVyZURhdGFgLiAqL1xuICBkZWNSZWYoZGF0YUlkOiBEYXRhSWQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50ZXhEYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICBjb25zdCB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgdGV4RGF0YS5yZWZDb3VudC0tO1xuICAgIH1cbiAgfVxuXG4gIG92ZXJyaWRlIG1vdmUoXG4gICAgICBkYXRhSWQ6IERhdGFJZCwgdmFsdWVzOiBCYWNrZW5kVmFsdWVzLCBzaGFwZTogbnVtYmVyW10sIGR0eXBlOiBEYXRhVHlwZSxcbiAgICAgIHJlZkNvdW50OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoZW52KCkuZ2V0Qm9vbCgnREVCVUcnKSkge1xuICAgICAgdGhpcy5jaGVja051bWVyaWNhbFByb2JsZW1zKHZhbHVlcyk7XG4gICAgfVxuICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBgICtcbiAgICAgICAgICBgUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLmApO1xuICAgIH1cbiAgICB0aGlzLnRleERhdGEuc2V0KFxuICAgICAgICBkYXRhSWQsIHtzaGFwZSwgZHR5cGUsIHZhbHVlcywgdXNhZ2U6IFRleHR1cmVVc2FnZS5VUExPQUQsIHJlZkNvdW50fSk7XG4gIH1cblxuICBkaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0ZW5zb3JJbmZvOiBUZW5zb3JJbmZvKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlRGF0YSh0ZW5zb3JJbmZvLmRhdGFJZCk7XG4gIH1cblxuICBvdmVycmlkZSByZWFkU3luYyhkYXRhSWQ6IERhdGFJZCk6IEJhY2tlbmRWYWx1ZXMge1xuICAgIGNvbnN0IHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgY29uc3Qge3ZhbHVlcywgZHR5cGUsIGNvbXBsZXhUZW5zb3JJbmZvcywgc2xpY2UsIHNoYXBlLCBpc1BhY2tlZH0gPSB0ZXhEYXRhO1xuXG4gICAgLy8gVGhlIHByZXNlbmNlIG9mIGBzbGljZWAgaW5kaWNhdGVzIHRoaXMgdGVuc29yIGlzIGEgc2hhbGxvdyBzbGljZSBvZiBhXG4gICAgLy8gZGlmZmVyZW50IHRlbnNvciwgYW5kIGlzIHVzaW5nIHRoYXQgb3JpZ2luYWwgdGVuc29yJ3MgdGV4dHVyZS4gUnVuXG4gICAgLy8gYGNsb25lYCBpbiBvcmRlciB0byBjb3B5IHRoYXQgdGV4dHVyZSBhbmQgcmVhZCBmcm9tIGl0LlxuICAgIGlmIChzbGljZSAhPSBudWxsKSB7XG4gICAgICBsZXQgcHJvZ3JhbTtcbiAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQYWNrZWRQcm9ncmFtKHNoYXBlLCB1bmFyeV9vcC5DTE9ORSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKHNoYXBlLCB1bmFyeV9vcC5DTE9ORSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPVxuICAgICAgICAgIHRoaXMucnVuV2ViR0xQcm9ncmFtKHByb2dyYW0sIFt7ZGF0YUlkLCBzaGFwZSwgZHR5cGV9XSwgZHR5cGUpO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMucmVhZFN5bmMocmVzLmRhdGFJZCk7XG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlcyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVShkYXRhSWQpO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRUaW1lUHJvZ3JhbSA9IHRoaXMuYWN0aXZlVGltZXJzICE9IG51bGw7XG4gICAgbGV0IHN0YXJ0OiBudW1iZXI7XG4gICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICBzdGFydCA9IHV0aWwubm93KCk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdDogRmxvYXQzMkFycmF5O1xuICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgIGNvbnN0IHJlYWxWYWx1ZXMgPVxuICAgICAgICAgIHRoaXMucmVhZFN5bmMoY29tcGxleFRlbnNvckluZm9zLnJlYWwuZGF0YUlkKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCBpbWFnVmFsdWVzID1cbiAgICAgICAgICB0aGlzLnJlYWRTeW5jKGNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmRhdGFJZCkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgcmVzdWx0ID0gYmFja2VuZF91dGlsLm1lcmdlUmVhbEFuZEltYWdBcnJheXMocmVhbFZhbHVlcywgaW1hZ1ZhbHVlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUoZGF0YUlkKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgIHRoaXMuZG93bmxvYWRXYWl0TXMgKz0gdXRpbC5ub3coKSAtIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVShkYXRhSWQsIHJlc3VsdCk7XG4gIH1cblxuICBvdmVycmlkZSBhc3luYyByZWFkKGRhdGFJZDogRGF0YUlkKTogUHJvbWlzZTxCYWNrZW5kVmFsdWVzPiB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1JlYWQuaGFzKGRhdGFJZCkpIHtcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5wZW5kaW5nUmVhZC5nZXQoZGF0YUlkKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxUeXBlZEFycmF5PihyZXNvbHZlID0+IHN1YnNjcmliZXJzLnB1c2gocmVzb2x2ZSkpO1xuICAgIH1cbiAgICBjb25zdCB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgIGNvbnN0IHt2YWx1ZXMsIHNoYXBlLCBzbGljZSwgZHR5cGUsIGNvbXBsZXhUZW5zb3JJbmZvcywgaXNQYWNrZWR9ID0gdGV4RGF0YTtcblxuICAgIC8vIFRoZSBwcmVzZW5jZSBvZiBgc2xpY2VgIGluZGljYXRlcyB0aGlzIHRlbnNvciBpcyBhIHNoYWxsb3cgc2xpY2Ugb2YgYVxuICAgIC8vIGRpZmZlcmVudCB0ZW5zb3IsIGFuZCBpcyB1c2luZyB0aGF0IG9yaWdpbmFsIHRlbnNvcidzIHRleHR1cmUuIFJ1blxuICAgIC8vIGBjbG9uZWAgaW4gb3JkZXIgdG8gY29weSB0aGF0IHRleHR1cmUgYW5kIHJlYWQgZnJvbSBpdC5cbiAgICBpZiAoc2xpY2UgIT0gbnVsbCkge1xuICAgICAgbGV0IHByb2dyYW07XG4gICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUGFja2VkUHJvZ3JhbShzaGFwZSwgdW5hcnlfb3AuQ0xPTkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbShzaGFwZSwgdW5hcnlfb3AuQ0xPTkUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID1cbiAgICAgICAgICB0aGlzLnJ1bldlYkdMUHJvZ3JhbShwcm9ncmFtLCBbe2RhdGFJZCwgc2hhcGUsIGR0eXBlfV0sIGR0eXBlKTtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlYWQocmVzLmRhdGFJZCk7XG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHJlcyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKGRhdGFJZCk7XG4gICAgfVxuXG4gICAgaWYgKGVudigpLmdldEJvb2woJ0RFQlVHJykpIHtcbiAgICAgIC8vIGdldEJvb2woJ1dFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQnKSBjYXVzZWQgYSBibG9ja2luZyBHUFUgY2FsbC5cbiAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb24sIG9ubHkgY2hlY2sgaXQgZm9yIGRlYnVnZ2luZy4gSW4gcHJvZHVjdGlvbixcbiAgICAgIC8vIGl0IGRvZXNuJ3QgaGFuZGxlIHRoaXMgdXNlIGNhc2UgYW55d2F5LCBzbyBiZWhhdmlvciBpcyBub3QgY2hhbmdlZC5cbiAgICAgIGlmICghZW52KCkuZ2V0Qm9vbCgnV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRCcpICYmXG4gICAgICAgICAgZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHRlbnNvci5kYXRhKCkgd2l0aCBXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEPWZhbHNlIGFuZCBgICtcbiAgICAgICAgICAgIGBXRUJHTF9WRVJTSU9OPTIgbm90IHlldCBzdXBwb3J0ZWQuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGJ1ZmZlcjogV2ViR0xCdWZmZXIgPSBudWxsO1xuICAgIGxldCB0bXBEb3dubG9hZFRhcmdldDogVGVuc29ySW5mbztcblxuICAgIGlmIChkdHlwZSAhPT0gJ2NvbXBsZXg2NCcgJiYgZW52KCkuZ2V0KCdXRUJHTF9CVUZGRVJfU1VQUE9SVEVEJykpIHtcbiAgICAgIC8vIFBvc3NpYmx5IGNvcHkgdGhlIHRleHR1cmUgaW50byBhIGJ1ZmZlciBiZWZvcmUgaW5zZXJ0aW5nIGEgZmVuY2UuXG4gICAgICB0bXBEb3dubG9hZFRhcmdldCA9IHRoaXMuZGVjb2RlKGRhdGFJZCk7XG4gICAgICBjb25zdCB0bXBEYXRhID0gdGhpcy50ZXhEYXRhLmdldCh0bXBEb3dubG9hZFRhcmdldC5kYXRhSWQpO1xuXG4gICAgICBidWZmZXIgPSB0aGlzLmdwZ3B1LmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlKFxuICAgICAgICAgIHRtcERhdGEudGV4dHVyZS50ZXh0dXJlLCAuLi50ZXhfdXRpbC5nZXREZW5zZVRleFNoYXBlKHNoYXBlKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nUmVhZC5zZXQoZGF0YUlkLCBbXSk7XG5cbiAgICBpZiAoZHR5cGUgIT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAvLyBDcmVhdGUgYSBmZW5jZSBhbmQgd2FpdCBmb3IgaXQgdG8gcmVzb2x2ZS5cbiAgICAgIGF3YWl0IHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7XG4gICAgfVxuXG4gICAgLy8gRG93bmxvYWQgdGhlIHZhbHVlcyBmcm9tIHRoZSBHUFUuXG4gICAgbGV0IHZhbHM6IEZsb2F0MzJBcnJheTtcbiAgICBpZiAoZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICBjb25zdCBwcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5yZWFkKGNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCksXG4gICAgICAgIHRoaXMucmVhZChjb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQpXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgcmVhbFZhbHVlcyA9IHBzWzBdO1xuICAgICAgY29uc3QgaW1hZ1ZhbHVlcyA9IHBzWzFdO1xuICAgICAgdmFscyA9IGJhY2tlbmRfdXRpbC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKFxuICAgICAgICAgIHJlYWxWYWx1ZXMgYXMgRmxvYXQzMkFycmF5LCBpbWFnVmFsdWVzIGFzIEZsb2F0MzJBcnJheSk7XG4gICAgfSBlbHNlIGlmIChidWZmZXIgPT0gbnVsbCkge1xuICAgICAgdmFscyA9IHRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUoZGF0YUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICB2YWxzID0gdGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKGJ1ZmZlciwgc2l6ZSk7XG4gICAgfVxuICAgIGlmICh0bXBEb3dubG9hZFRhcmdldCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHRtcERvd25sb2FkVGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ3BncHUuZ2w7XG4gICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZGVsZXRlQnVmZmVyKGJ1ZmZlcikpO1xuICAgIH1cbiAgICBjb25zdCBkVHlwZVZhbHMgPSB0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKGRhdGFJZCwgdmFscyk7XG5cbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUoZGF0YUlkKTtcblxuICAgIC8vIE5vdGlmeSBhbGwgcGVuZGluZyByZWFkcy5cbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKHJlc29sdmUgPT4gcmVzb2x2ZShkVHlwZVZhbHMpKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKGRhdGFJZCkpIHtcbiAgICAgIHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgaWYgKHRoaXMuZGlzcG9zZURhdGEoZGF0YUlkKSkge1xuICAgICAgICBlbmdpbmUoKS5yZW1vdmVEYXRhSWQoZGF0YUlkLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0RlbGV0ZXMtLTtcbiAgICB9XG4gICAgcmV0dXJuIGRUeXBlVmFscztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRlbnNvciB0byBhIG5ldyB0ZXh0dXJlIHRoYXQgaXMgZGVuc2VseSBwYWNrZWQgZm9yIGVhc2Ugb2YgdXNlLlxuICAgKiBAcGFyYW0gZGF0YUlkIFRoZSBzb3VyY2UgdGVuc29yLlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiAgICAgY3VzdG9tVGV4U2hhcGU6IE9wdGlvbmFsLiBJZiBzZXQsIHdpbGwgdXNlIHRoZSB1c2VyIGRlZmluZWQgdGV4dHVyZVxuICAgKiAgICAgc2hhcGUgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgb3ZlcnJpZGUgcmVhZFRvR1BVKGRhdGFJZDogRGF0YUlkLCBvcHRpb25zOiBEYXRhVG9HUFVXZWJHTE9wdGlvbiA9IHt9KTpcbiAgICAgIEdQVURhdGEge1xuICAgIGNvbnN0IHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgY29uc3Qge3ZhbHVlcywgc2hhcGUsIHNsaWNlLCBkdHlwZSwgaXNQYWNrZWQsIHRleHR1cmV9ID0gdGV4RGF0YTtcblxuICAgIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIHRleHR1cmUgZm9yIGNvbXBsZXg2NCBkdHlwZS4nKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlc2VuY2Ugb2YgYHNsaWNlYCBpbmRpY2F0ZXMgdGhpcyB0ZW5zb3IgaXMgYSBzaGFsbG93IHNsaWNlIG9mIGFcbiAgICAvLyBkaWZmZXJlbnQgdGVuc29yLCBhbmQgaXMgdXNpbmcgdGhhdCBvcmlnaW5hbCB0ZW5zb3IncyB0ZXh0dXJlLiBSdW5cbiAgICAvLyBgY2xvbmVgIGluIG9yZGVyIHRvIGNvcHkgdGhhdCB0ZXh0dXJlIGFuZCByZWFkIGZyb20gaXQuXG4gICAgaWYgKHNsaWNlICE9IG51bGwpIHtcbiAgICAgIGxldCBwcm9ncmFtO1xuICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFBhY2tlZFByb2dyYW0oc2hhcGUsIHVuYXJ5X29wLkNMT05FKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oc2hhcGUsIHVuYXJ5X29wLkNMT05FKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9XG4gICAgICAgICAgdGhpcy5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW3tkYXRhSWQsIHNoYXBlLCBkdHlwZX1dLCBkdHlwZSk7XG4gICAgICBjb25zdCBncHVSZXNvdW9yY2UgPSB0aGlzLnJlYWRUb0dQVShyZXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyZXMpO1xuICAgICAgcmV0dXJuIGdwdVJlc291b3JjZTtcbiAgICB9XG5cbiAgICBpZiAodGV4dHVyZSA9PSBudWxsKSB7XG4gICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG5vdCBvbiBHUFUgYnV0IG9uIENQVS4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gZGF0YSBvbiBHUFUgb3IgQ1BVLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlY29kZSB0aGUgdGV4dHVyZSBzbyB0aGF0IGl0IGlzIHN0b3JlZCBkZW5zZWx5ICh1c2luZyBmb3VyIGNoYW5uZWxzKS5cbiAgICBjb25zdCB0bXBUYXJnZXQgPSB0aGlzLmRlY29kZShkYXRhSWQsIG9wdGlvbnMuY3VzdG9tVGV4U2hhcGUpO1xuXG4gICAgLy8gTWFrZSBlbmdpbmUgdHJhY2sgdGhpcyB0ZW5zb3IsIHNvIHRoYXQgd2UgY2FuIGRpc3Bvc2UgaXQgbGF0ZXIuXG4gICAgY29uc3QgdGVuc29yUmVmID0gZW5naW5lKCkubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKHRtcFRhcmdldCk7XG5cbiAgICBjb25zdCB0bXBEYXRhID0gdGhpcy50ZXhEYXRhLmdldCh0bXBUYXJnZXQuZGF0YUlkKTtcbiAgICByZXR1cm4ge3RlbnNvclJlZiwgLi4udG1wRGF0YS50ZXh0dXJlfTtcbiAgfVxuXG4gIGJ1ZmZlclN5bmM8UiBleHRlbmRzIFJhbmssIEQgZXh0ZW5kcyBEYXRhVHlwZT4odDogVGVuc29ySW5mbyk6XG4gICAgICBUZW5zb3JCdWZmZXI8UiwgRD4ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKTtcbiAgICBpZiAodC5kdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIERlY29kZSB0aGUgYnl0ZXMgaW50byBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSAoZGF0YSBhcyBVaW50OEFycmF5W10pLm1hcChkID0+IHV0aWwuZGVjb2RlU3RyaW5nKGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcih0LnNoYXBlIGFzIFNoYXBlTWFwW1JdLCB0LmR0eXBlLCBzdHJpbmdzKSBhc1xuICAgICAgICAgICAgVGVuc29yQnVmZmVyPFIsIEQ+O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY29kZSBlbmNvZGVkIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIodC5zaGFwZSBhcyBTaGFwZU1hcFtSXSwgdC5kdHlwZSwgZGF0YSBhcyBUeXBlZEFycmF5KSBhc1xuICAgICAgICBUZW5zb3JCdWZmZXI8UiwgRD47XG4gIH1cblxuICBwcml2YXRlIGNoZWNrTnVtZXJpY2FsUHJvYmxlbXModmFsdWVzOiBCYWNrZW5kVmFsdWVzKTogdm9pZCB7XG4gICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBudW0gPSB2YWx1ZXNbaV0gYXMgbnVtYmVyO1xuICAgICAgaWYgKCF3ZWJnbF91dGlsLmNhbkJlUmVwcmVzZW50ZWQobnVtKSkge1xuICAgICAgICBpZiAoZW52KCkuZ2V0Qm9vbCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRScpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIGBUaGUgdmFsdWUgJHtudW19IGNhbm5vdCBiZSByZXByZXNlbnRlZCB3aXRoIHlvdXIgYCArXG4gICAgICAgICAgICAgIGBjdXJyZW50IHNldHRpbmdzLiBDb25zaWRlciBlbmFibGluZyBmbG9hdDMyIHJlbmRlcmluZzogYCArXG4gICAgICAgICAgICAgIGAndGYuZW52KCkuc2V0KCdXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEJywgdHJ1ZSk7J2ApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKGBUaGUgdmFsdWUgJHtudW19IGNhbm5vdCBiZSByZXByZXNlbnRlZCBvbiB0aGlzIGRldmljZS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFZhbHVlc0Zyb21UZXh0dXJlKGRhdGFJZDogRGF0YUlkKTogRmxvYXQzMkFycmF5IHtcbiAgICBjb25zdCB7c2hhcGUsIGR0eXBlLCBpc1BhY2tlZH0gPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgY29uc3Qgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgaWYgKGVudigpLmdldEJvb2woJ1dFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQnKSkge1xuICAgICAgY29uc3QgdG1wVGFyZ2V0ID0gdGhpcy5kZWNvZGUoZGF0YUlkKTtcbiAgICAgIGNvbnN0IHRtcERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KHRtcFRhcmdldC5kYXRhSWQpO1xuICAgICAgY29uc3QgdmFscyA9XG4gICAgICAgICAgdGhpcy5ncGdwdVxuICAgICAgICAgICAgICAuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZShcbiAgICAgICAgICAgICAgICAgIHRtcERhdGEudGV4dHVyZS50ZXh0dXJlLCAuLi50ZXhfdXRpbC5nZXREZW5zZVRleFNoYXBlKHNoYXBlKSlcbiAgICAgICAgICAgICAgLnN1YmFycmF5KDAsIHNpemUpO1xuXG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHRtcFRhcmdldCk7XG5cbiAgICAgIHJldHVybiB2YWxzO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZFVzZVBhY2tlZFByb2dyYW0gPVxuICAgICAgICBlbnYoKS5nZXRCb29sKCdXRUJHTF9QQUNLJykgJiYgaXNQYWNrZWQgPT09IHRydWU7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICBzaG91bGRVc2VQYWNrZWRQcm9ncmFtID8gd2ViZ2xfdXRpbC5nZXRTaGFwZUFzM0Qoc2hhcGUpIDogc2hhcGU7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHNob3VsZFVzZVBhY2tlZFByb2dyYW0gP1xuICAgICAgICBuZXcgRW5jb2RlRmxvYXRQYWNrZWRQcm9ncmFtKG91dHB1dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSkgOlxuICAgICAgICBuZXcgRW5jb2RlRmxvYXRQcm9ncmFtKG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLnJ1bldlYkdMUHJvZ3JhbShcbiAgICAgICAgcHJvZ3JhbSwgW3tzaGFwZTogb3V0cHV0U2hhcGUsIGR0eXBlLCBkYXRhSWR9XSwgJ2Zsb2F0MzInKTtcbiAgICBjb25zdCB0bXBEYXRhID0gdGhpcy50ZXhEYXRhLmdldChvdXRwdXQuZGF0YUlkKTtcbiAgICBjb25zdCB2YWxzID0gdGhpcy5ncGdwdVxuICAgICAgICAgICAgICAgICAgICAgLmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRtcERhdGEudGV4dHVyZS50ZXh0dXJlLCB0bXBEYXRhLnRleFNoYXBlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRtcERhdGEudGV4U2hhcGVbMV0pXG4gICAgICAgICAgICAgICAgICAgICAuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvdXRwdXQpO1xuXG4gICAgcmV0dXJuIHZhbHM7XG4gIH1cblxuICBvdmVycmlkZSB0aW1lckF2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEUnKSA+IDA7XG4gIH1cblxuICBvdmVycmlkZSB0aW1lKGY6ICgpID0+IHZvaWQpOiBQcm9taXNlPFdlYkdMVGltaW5nSW5mbz4ge1xuICAgIGNvbnN0IG9sZEFjdGl2ZVRpbWVycyA9IHRoaXMuYWN0aXZlVGltZXJzO1xuICAgIGNvbnN0IG5ld0FjdGl2ZVRpbWVyczogVGltZXJOb2RlW10gPSBbXTtcblxuICAgIGxldCBvdXRlck1vc3RUaW1lID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrID09IG51bGwpIHtcbiAgICAgIHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrID0gbmV3QWN0aXZlVGltZXJzO1xuICAgICAgb3V0ZXJNb3N0VGltZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZlVGltZXJzLnB1c2gobmV3QWN0aXZlVGltZXJzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVUaW1lcnMgPSBuZXdBY3RpdmVUaW1lcnM7XG5cbiAgICBmKCk7XG5cbiAgICAvLyBuZWVkaW5nIHRvIHNwbGl0IHRoZXNlIHVwIGJlY2F1c2UgdXRpbC5mbGF0dGVuIG9ubHkgYWNjZXB0cyBjZXJ0YWluIHR5cGVzXG4gICAgY29uc3QgZmxhdHRlbmVkQWN0aXZlVGltZXJRdWVyaWVzID1cbiAgICAgICAgdXRpbC5mbGF0dGVuKHRoaXMuYWN0aXZlVGltZXJzLm1hcCgoZDogS2VybmVsSW5mbykgPT4gZC5xdWVyeSkpXG4gICAgICAgICAgICAuZmlsdGVyKGQgPT4gZCAhPSBudWxsKTtcbiAgICBjb25zdCBmbGF0dGVuZWRBY3RpdmVUaW1lck5hbWVzID1cbiAgICAgICAgdXRpbC5mbGF0dGVuKHRoaXMuYWN0aXZlVGltZXJzLm1hcCgoZDogS2VybmVsSW5mbykgPT4gZC5uYW1lKSlcbiAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkICE9IG51bGwpO1xuXG4gICAgdGhpcy5hY3RpdmVUaW1lcnMgPSBvbGRBY3RpdmVUaW1lcnM7XG5cbiAgICBpZiAob3V0ZXJNb3N0VGltZSkge1xuICAgICAgdGhpcy5wcm9ncmFtVGltZXJzU3RhY2sgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlczogV2ViR0xUaW1pbmdJbmZvID0ge1xuICAgICAgdXBsb2FkV2FpdE1zOiB0aGlzLnVwbG9hZFdhaXRNcyxcbiAgICAgIGRvd25sb2FkV2FpdE1zOiB0aGlzLmRvd25sb2FkV2FpdE1zLFxuICAgICAga2VybmVsTXM6IG51bGwsXG4gICAgICB3YWxsTXM6IG51bGwgIC8vIHdpbGwgYmUgZmlsbGVkIGJ5IHRoZSBlbmdpbmVcbiAgICB9O1xuXG4gICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoZW52KCkuZ2V0TnVtYmVyKCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEUnKSA+XG4gICAgICAgICAgMCkge1xuICAgICAgICBjb25zdCBrZXJuZWxNcyA9IGF3YWl0IFByb21pc2UuYWxsKGZsYXR0ZW5lZEFjdGl2ZVRpbWVyUXVlcmllcyk7XG5cbiAgICAgICAgcmVzWydrZXJuZWxNcyddID0gdXRpbC5zdW0oa2VybmVsTXMpO1xuICAgICAgICByZXNbJ2dldEV4dHJhUHJvZmlsZUluZm8nXSA9ICgpID0+XG4gICAgICAgICAgICBrZXJuZWxNc1xuICAgICAgICAgICAgICAgIC5tYXAoKGQsIGkpID0+ICh7bmFtZTogZmxhdHRlbmVkQWN0aXZlVGltZXJOYW1lc1tpXSwgbXM6IGR9KSlcbiAgICAgICAgICAgICAgICAubWFwKGQgPT4gYCR7ZC5uYW1lfTogJHtkLm1zfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNbJ2tlcm5lbE1zJ10gPSB7XG4gICAgICAgICAgZXJyb3I6ICdXZWJHTCBxdWVyeSB0aW1lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBsb2FkV2FpdE1zID0gMDtcbiAgICAgIHRoaXMuZG93bmxvYWRXYWl0TXMgPSAwO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KSgpO1xuICB9XG4gIG92ZXJyaWRlIG1lbW9yeSgpOiBXZWJHTE1lbW9yeUluZm8ge1xuICAgIHJldHVybiB7XG4gICAgICB1bnJlbGlhYmxlOiBmYWxzZSxcbiAgICAgIG51bUJ5dGVzSW5HUFU6IHRoaXMubnVtQnl0ZXNJbkdQVSxcbiAgICAgIG51bUJ5dGVzSW5HUFVBbGxvY2F0ZWQ6IHRoaXMudGV4dHVyZU1hbmFnZXIubnVtQnl0ZXNBbGxvY2F0ZWQsXG4gICAgICBudW1CeXRlc0luR1BVRnJlZTogdGhpcy50ZXh0dXJlTWFuYWdlci5udW1CeXRlc0ZyZWVcbiAgICB9IGFzIFdlYkdMTWVtb3J5SW5mbztcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRUaW1lcigpOiBXZWJHTFF1ZXJ5fENQVVRpbWVyUXVlcnkge1xuICAgIGlmIChlbnYoKS5nZXROdW1iZXIoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScpID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ3BncHUuYmVnaW5RdWVyeSgpO1xuICAgIH1cbiAgICByZXR1cm4ge3N0YXJ0TXM6IHV0aWwubm93KCksIGVuZE1zOiBudWxsfTtcbiAgfVxuXG4gIHByaXZhdGUgZW5kVGltZXIocXVlcnk6IFdlYkdMUXVlcnl8Q1BVVGltZXJRdWVyeSk6IFdlYkdMUXVlcnl8Q1BVVGltZXJRdWVyeSB7XG4gICAgaWYgKGVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykgPiAwKSB7XG4gICAgICB0aGlzLmdwZ3B1LmVuZFF1ZXJ5KCk7XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuICAgIChxdWVyeSBhcyBDUFVUaW1lclF1ZXJ5KS5lbmRNcyA9IHV0aWwubm93KCk7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRRdWVyeVRpbWUocXVlcnk6IFdlYkdMUXVlcnl8Q1BVVGltZXJRdWVyeSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKGVudigpLmdldE51bWJlcignV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykgPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncGdwdS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHF1ZXJ5IGFzIFdlYkdMUXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lclF1ZXJ5ID0gcXVlcnkgYXMgQ1BVVGltZXJRdWVyeTtcbiAgICByZXR1cm4gdGltZXJRdWVyeS5lbmRNcyAtIHRpbWVyUXVlcnkuc3RhcnRNcztcbiAgfVxuXG4gIHByaXZhdGUgcGVuZGluZ0RlbGV0ZXMgPSAwO1xuXG4gIC8qKlxuICAgKiBEZWNyZWFzZSB0aGUgUmVmQ291bnQgb24gdGhlIGRhdGFJZCBhbmQgZGlzcG9zZSB0aGUgbWVtb3J5IGlmIHRoZSBkYXRhSWRcbiAgICogaGFzIDAgcmVmQ291bnQuIElmIHRoZXJlIGFyZSBwZW5kaW5nIHJlYWQgb24gdGhlIGRhdGEsIHRoZSBkaXNwb3NhbCB3b3VsZFxuICAgKiBhZGRlZCB0byB0aGUgcGVuZGluZyBkZWxldGUgcXVldWUuIFJldHVybiB0cnVlIGlmIHRoZSBkYXRhSWQgaXMgcmVtb3ZlZFxuICAgKiBmcm9tIGJhY2tlbmQgb3IgdGhlIGJhY2tlbmQgZG9lcyBub3QgY29udGFpbiB0aGUgZGF0YUlkLCBmYWxzZSBpZiB0aGVcbiAgICogZGF0YUlkIGlzIG5vdCByZW1vdmVkLiBNZW1vcnkgbWF5IG9yIG1heSBub3QgYmUgcmVsZWFzZWQgZXZlbiB3aGVuIGRhdGFJZFxuICAgKiBpcyByZW1vdmVkLCB3aGljaCBhbHNvIGRlcGVuZHMgb24gZGF0YVJlZkNvdW50LCBzZWUgYHJlbGVhc2VHUFVgLlxuICAgKiBAcGFyYW0gZGF0YUlkXG4gICAqIEBvYXJhbSBmb3JjZSBPcHRpb25hbCwgcmVtb3ZlIHRoZSBkYXRhIHJlZ2FyZGxlc3Mgb2YgcmVmQ291bnRcbiAgICovXG4gIG92ZXJyaWRlIGRpc3Bvc2VEYXRhKGRhdGFJZDogRGF0YUlkLCBmb3JjZSA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyhkYXRhSWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTm8tb3AgaWYgYWxyZWFkeSBkaXNwb3NlZC5cbiAgICBpZiAoIXRoaXMudGV4RGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgZm9yY2UgZmxhZyBpcyBzZXQsIGNoYW5nZSByZWZDb3VudCB0byAwLCB0aGlzIHdvdWxkIGVuc3VyZSBkaXNwb3NhbFxuICAgIC8vIHdoZW4gYWRkZWQgdG8gdGhlIHBlbmRpbmdEaXNwb3NhbCBxdWV1ZS4gTWVtb3J5IG1heSBvciBtYXkgbm90IGJlXG4gICAgLy8gcmVsZWFzZWQsIHdoaWNoIGFsc28gZGVwZW5kcyBvbiBkYXRhUmVmQ291bnQsIHNlZSBgcmVsZWFzZUdQVWAuXG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCkucmVmQ291bnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCkucmVmQ291bnQtLTtcbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlICYmIHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKS5yZWZDb3VudCA+IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wZW5kaW5nUmVhZC5oYXMoZGF0YUlkKSkge1xuICAgICAgdGhpcy5wZW5kaW5nRGlzcG9zYWwuYWRkKGRhdGFJZCk7XG4gICAgICB0aGlzLnBlbmRpbmdEZWxldGVzKys7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxlYXNlR1BVRGF0YShkYXRhSWQpO1xuICAgIGNvbnN0IHtjb21wbGV4VGVuc29ySW5mb3N9ID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgIGlmIChjb21wbGV4VGVuc29ySW5mb3MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kaXNwb3NlRGF0YShjb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQsIGZvcmNlKTtcbiAgICAgIHRoaXMuZGlzcG9zZURhdGEoY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkLCBmb3JjZSk7XG4gICAgfVxuXG4gICAgdGhpcy50ZXhEYXRhLmRlbGV0ZShkYXRhSWQpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHJlbGVhc2VHUFVEYXRhKGRhdGFJZDogRGF0YUlkKTogdm9pZCB7XG4gICAgY29uc3Qge3RleHR1cmUsIGR0eXBlLCB0ZXhTaGFwZSwgdXNhZ2UsIGlzUGFja2VkLCBzbGljZX0gPVxuICAgICAgICB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgY29uc3Qga2V5ID0gc2xpY2UgJiYgc2xpY2Uub3JpZ0RhdGFJZCB8fCBkYXRhSWQ7XG4gICAgY29uc3QgcmVmQ291bnQgPSB0aGlzLmRhdGFSZWZDb3VudC5nZXQoa2V5KTtcblxuICAgIGlmIChyZWZDb3VudCA+IDEpIHtcbiAgICAgIHRoaXMuZGF0YVJlZkNvdW50LnNldChrZXksIHJlZkNvdW50IC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YVJlZkNvdW50LmRlbGV0ZShrZXkpO1xuICAgICAgaWYgKHRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLm51bUJ5dGVzSW5HUFUgLT0gdGhpcy5jb21wdXRlQnl0ZXModGV4U2hhcGUsIGR0eXBlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0ZXh0dXJlLCB0ZXhTaGFwZSwgdXNhZ2UsIGlzUGFja2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgIHRleERhdGEudGV4dHVyZSA9IG51bGw7XG4gICAgdGV4RGF0YS50ZXhTaGFwZSA9IG51bGw7XG4gICAgdGV4RGF0YS5pc1BhY2tlZCA9IGZhbHNlO1xuICAgIHRleERhdGEuc2xpY2UgPSBudWxsO1xuICB9XG5cbiAgZ2V0VGV4dHVyZShkYXRhSWQ6IERhdGFJZCk6IFdlYkdMVGV4dHVyZSB7XG4gICAgdGhpcy51cGxvYWRUb0dQVShkYXRhSWQpO1xuICAgIHJldHVybiB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCkudGV4dHVyZS50ZXh0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZXJuYWwgaW5mb3JtYXRpb24gZm9yIHRoZSBzcGVjaWZpYyBkYXRhIGJ1Y2tldC4gVXNlZCBpbiB1bml0XG4gICAqIHRlc3RzLlxuICAgKi9cbiAgZ2V0RGF0YUluZm8oZGF0YUlkOiBEYXRhSWQpOiBUZXh0dXJlRGF0YSB7XG4gICAgcmV0dXJuIHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgfVxuXG4gIC8qXG4gIFRlc3RzIHdoZXRoZXIgYWxsIHRoZSBpbnB1dHMgdG8gYW4gb3AgYXJlIHNtYWxsIGFuZCBvbiB0aGUgQ1BVLiBUaGlzIGhldXJpc3RpY1xuICBkZXRlcm1pbmVzIHdoZW4gaXQgd291bGQgYmUgZmFzdGVyIHRvIGV4ZWN1dGUgYSBrZXJuZWwgb24gdGhlIENQVS4gV2ViR0xcbiAga2VybmVscyBvcHQgaW50byBydW5uaW5nIHRoaXMgY2hlY2sgYW5kIGZvcndhcmRpbmcgd2hlbiBhcHByb3ByaWF0ZS5cbiAgVE9ETyhodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy84NzIpOiBEZXZlbG9wIGEgbW9yZVxuICBzdXN0YWluYWJsZSBzdHJhdGVneSBmb3Igb3B0aW1pemluZyBiYWNrZW5kIGV4ZWN1dGlvbiBvZiBvcHMuXG4gICAqL1xuICBzaG91bGRFeGVjdXRlT25DUFUoXG4gICAgICBpbnB1dHM6IFRlbnNvckluZm9bXSxcbiAgICAgIHNpemVUaHJlc2hvbGQgPSBDUFVfSEFORE9GRl9TSVpFX1RIUkVTSE9MRCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlbnYoKS5nZXRCb29sKCdXRUJHTF9DUFVfRk9SV0FSRCcpICYmXG4gICAgICAgIGlucHV0cy5ldmVyeShcbiAgICAgICAgICAgIGlucHV0ID0+IHRoaXMudGV4RGF0YS5nZXQoaW5wdXQuZGF0YUlkKS50ZXh0dXJlID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoaW5wdXQuc2hhcGUpIDwgc2l6ZVRocmVzaG9sZCk7XG4gIH1cblxuICBnZXRHUEdQVUNvbnRleHQoKTogR1BHUFVDb250ZXh0IHtcbiAgICByZXR1cm4gdGhpcy5ncGdwdTtcbiAgfVxuXG4gIHdoZXJlKGNvbmRpdGlvbjogVGVuc29yKTogVGVuc29yMkQge1xuICAgIGJhY2tlbmRfdXRpbC53YXJuKFxuICAgICAgICAndGYud2hlcmUoKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiAnICtcbiAgICAgICAgJ0NhbGwgdGYud2hlcmVBc3luYygpIGluc3RlYWQnKTtcbiAgICBjb25zdCBjb25kVmFscyA9IGNvbmRpdGlvbi5kYXRhU3luYygpO1xuICAgIHJldHVybiB3aGVyZUltcGwoY29uZGl0aW9uLnNoYXBlLCBjb25kVmFscyk7XG4gIH1cblxuICBwcml2YXRlIHBhY2tlZFVuYXJ5T3AoeDogVGVuc29ySW5mbywgb3A6IHN0cmluZywgZHR5cGU6IERhdGFUeXBlKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUGFja2VkUHJvZ3JhbSh4LnNoYXBlLCBvcCk7XG4gICAgY29uc3Qgb3V0SW5mbyA9IHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIGR0eXBlKTtcbiAgICByZXR1cm4gZW5naW5lKCkubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKG91dEluZm8pO1xuICB9XG5cbiAgLy8gVE9ETyhtc291bGFuaWxsZSkgcmVtb3ZlIHRoaXMgb25jZSB0aGUgYmFja2VuZCBoYXMgYmVlbiBtb2R1bGFyaXplZFxuICAvLyBhIGNvcHkgaXMgbmVlZGVkIGhlcmUgdG8gYnJlYWsgYSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAvLyBBbHNvIHJlbW92ZSB0aGUgb3AgZnJvbSB1bmFyeV9vcC5cbiAgYWJzPFQgZXh0ZW5kcyBUZW5zb3I+KHg6IFQpOiBUIHtcbiAgICAvLyBUT0RPOiBoYW5kbGUgY2FzZXMgd2hlbiB4IGlzIGNvbXBsZXguXG4gICAgaWYgKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt4XSkgJiYgeC5kdHlwZSAhPT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgIGNvbnN0IG91dFZhbHVlcyA9XG4gICAgICAgICAgc2ltcGxlQWJzSW1wbENQVSh0aGlzLnRleERhdGEuZ2V0KHguZGF0YUlkKS52YWx1ZXMgYXMgVHlwZWRBcnJheSk7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlT3V0cHV0KHguc2hhcGUsIHguZHR5cGUsIG91dFZhbHVlcyk7XG4gICAgfVxuXG4gICAgaWYgKGVudigpLmdldEJvb2woJ1dFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OUycpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHgsIHVuYXJ5X29wLkFCUywgeC5kdHlwZSkgYXMgVDtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFCUyk7XG4gICAgY29uc3Qgb3V0SW5mbyA9IHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIHJldHVybiBlbmdpbmUoKS5tYWtlVGVuc29yRnJvbVRlbnNvckluZm8ob3V0SW5mbykgYXMgVDtcbiAgfVxuXG4gIG1ha2VUZW5zb3JJbmZvKFxuICAgICAgc2hhcGU6IG51bWJlcltdLCBkdHlwZTogRGF0YVR5cGUsXG4gICAgICB2YWx1ZXM/OiBCYWNrZW5kVmFsdWVzfHN0cmluZ1tdKTogVGVuc29ySW5mbyB7XG4gICAgbGV0IGRhdGFJZDtcbiAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbHVlcyAhPSBudWxsICYmIHZhbHVlcy5sZW5ndGggPiAwICYmXG4gICAgICAgIHV0aWwuaXNTdHJpbmcodmFsdWVzWzBdKSkge1xuICAgICAgY29uc3QgZW5jb2RlZFZhbHVlcyA9XG4gICAgICAgICAgKHZhbHVlcyBhcyB7fSBhcyBzdHJpbmdbXSkubWFwKGQgPT4gdXRpbC5lbmNvZGVTdHJpbmcoZCkpO1xuXG4gICAgICBkYXRhSWQgPSB0aGlzLndyaXRlKGVuY29kZWRWYWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFJZCA9IHRoaXMud3JpdGUodmFsdWVzIGFzIFR5cGVkQXJyYXksIHNoYXBlLCBkdHlwZSk7XG4gICAgfVxuXG4gICAgdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLnVzYWdlID0gbnVsbDtcbiAgICByZXR1cm4ge2RhdGFJZCwgc2hhcGUsIGR0eXBlfTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZU91dHB1dDxUIGV4dGVuZHMgVGVuc29yPihcbiAgICAgIHNoYXBlOiBudW1iZXJbXSwgZHR5cGU6IERhdGFUeXBlLCB2YWx1ZXM/OiBCYWNrZW5kVmFsdWVzKTogVCB7XG4gICAgcmV0dXJuIGVuZ2luZSgpLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyhcbiAgICAgICAgICAgICAgIHRoaXMubWFrZVRlbnNvckluZm8oc2hhcGUsIGR0eXBlLCB2YWx1ZXMpLCB0aGlzKSBhcyBUO1xuICB9XG5cbiAgdW5wYWNrVGVuc29yKGlucHV0OiBUZW5zb3JJbmZvKTogVGVuc29ySW5mbyB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBVbnBhY2tQcm9ncmFtKGlucHV0LnNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0ocHJvZ3JhbSwgW2lucHV0XSwgaW5wdXQuZHR5cGUpO1xuICB9XG5cbiAgcGFja1RlbnNvcihpbnB1dDogVGVuc29ySW5mbyk6IFRlbnNvckluZm8ge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUGFja1Byb2dyYW0oaW5wdXQuc2hhcGUpO1xuICAgIGNvbnN0IHByZXZlbnRFYWdlclVucGFja2luZ091dHB1dCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMucnVuV2ViR0xQcm9ncmFtKFxuICAgICAgICBwcm9ncmFtLCBbaW5wdXRdLCBpbnB1dC5kdHlwZSwgbnVsbCAvKiBjdXN0b21Vbmlmb3JtVmFsdWVzICovLFxuICAgICAgICBwcmV2ZW50RWFnZXJVbnBhY2tpbmdPdXRwdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYWNrZWRSZXNoYXBlKGlucHV0OiBUZW5zb3JJbmZvLCBhZnRlclNoYXBlOiBudW1iZXJbXSk6IFRlbnNvckluZm8ge1xuICAgIGNvbnN0IGlucHV0M0RTaGFwZSA9IFtcbiAgICAgIHdlYmdsX3V0aWwuZ2V0QmF0Y2hEaW0oaW5wdXQuc2hhcGUpLFxuICAgICAgLi4ud2ViZ2xfdXRpbC5nZXRSb3dzQ29scyhpbnB1dC5zaGFwZSlcbiAgICBdIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBjb25zdCBpbnB1dDNEOiBUZW5zb3JJbmZvID0ge1xuICAgICAgZHR5cGU6IGlucHV0LmR0eXBlLFxuICAgICAgc2hhcGU6IGlucHV0M0RTaGFwZSxcbiAgICAgIGRhdGFJZDogaW5wdXQuZGF0YUlkXG4gICAgfTtcbiAgICBjb25zdCBhZnRlclNoYXBlQXMzRCA9IFtcbiAgICAgIHdlYmdsX3V0aWwuZ2V0QmF0Y2hEaW0oYWZ0ZXJTaGFwZSksIC4uLndlYmdsX3V0aWwuZ2V0Um93c0NvbHMoYWZ0ZXJTaGFwZSlcbiAgICBdIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUmVzaGFwZVBhY2tlZFByb2dyYW0oYWZ0ZXJTaGFwZUFzM0QsIGlucHV0M0RTaGFwZSk7XG4gICAgY29uc3QgcHJldmVudEVhZ2VyVW5wYWNraW5nT2ZPdXRwdXQgPSB0cnVlO1xuICAgIGNvbnN0IGN1c3RvbVZhbHVlcyA9IFtpbnB1dDNEU2hhcGVdO1xuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMucnVuV2ViR0xQcm9ncmFtKFxuICAgICAgICBwcm9ncmFtLCBbaW5wdXQzRF0sIGlucHV0LmR0eXBlLCBjdXN0b21WYWx1ZXMsXG4gICAgICAgIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0KTtcbiAgICByZXR1cm4ge2RhdGFJZDogb3V0cHV0LmRhdGFJZCwgc2hhcGU6IGFmdGVyU2hhcGUsIGR0eXBlOiBvdXRwdXQuZHR5cGV9O1xuICB9XG5cbiAgcHJpdmF0ZSBkZWNvZGUoZGF0YUlkOiBEYXRhSWQsIGN1c3RvbVRleFNoYXBlPzogW251bWJlciwgbnVtYmVyXSk6XG4gICAgICBUZW5zb3JJbmZvIHtcbiAgICBjb25zdCB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgIGNvbnN0IHtpc1BhY2tlZCwgc2hhcGUsIGR0eXBlfSA9IHRleERhdGE7XG4gICAgaWYgKGN1c3RvbVRleFNoYXBlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgY29uc3QgdGV4U2l6ZSA9IGN1c3RvbVRleFNoYXBlWzBdICogY3VzdG9tVGV4U2hhcGVbMV0gKiA0O1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgc2l6ZSA8PSB0ZXhTaXplLFxuICAgICAgICAgICgpID0+ICdjdXN0b21UZXhTaGFwZSBpcyB0b28gc21hbGwuICcgK1xuICAgICAgICAgICAgICAnUm93ICogQ29sdW1uICogNCBzaG91bGQgYmUgZXF1YWwgb3IgbGFyZ2VyIHRoYW4gdGhlICcgK1xuICAgICAgICAgICAgICAnc2l6ZSBvZiB0aGUgdGVuc29yIGRhdGEuJyk7XG4gICAgfVxuICAgIGNvbnN0IHNoYXBlQXMzRCA9XG4gICAgICAgIHdlYmdsX3V0aWwuZ2V0U2hhcGVBczNEKHNoYXBlKSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IHByb2dyYW07XG4gICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICBwcm9ncmFtID0gbmV3IERlY29kZU1hdHJpeFBhY2tlZFByb2dyYW0oc2hhcGVBczNEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3JhbSA9IG5ldyBEZWNvZGVNYXRyaXhQcm9ncmFtKHNoYXBlQXMzRCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID0gdHJ1ZTtcbiAgICBjb25zdCBjdXN0b21WYWx1ZXMgPVxuICAgICAgICBbY3VzdG9tVGV4U2hhcGUgIT0gbnVsbCA/IGN1c3RvbVRleFNoYXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXhfdXRpbC5nZXREZW5zZVRleFNoYXBlKHNoYXBlQXMzRCldO1xuICAgIGNvbnN0IG91dCA9IHRoaXMucnVuV2ViR0xQcm9ncmFtKFxuICAgICAgICBwcm9ncmFtLCBbe3NoYXBlOiBzaGFwZUFzM0QsIGR0eXBlLCBkYXRhSWR9XSwgZHR5cGUsIGN1c3RvbVZhbHVlcyxcbiAgICAgICAgcHJldmVudEVhZ2VyVW5wYWNraW5nT2ZPdXRwdXQsIGN1c3RvbVRleFNoYXBlKTtcbiAgICByZXR1cm4ge2R0eXBlLCBzaGFwZSwgZGF0YUlkOiBvdXQuZGF0YUlkfTtcbiAgfVxuXG4gIHJ1bldlYkdMUHJvZ3JhbShcbiAgICAgIHByb2dyYW06IEdQR1BVUHJvZ3JhbSwgaW5wdXRzOiBUZW5zb3JJbmZvW10sIG91dHB1dER0eXBlOiBEYXRhVHlwZSxcbiAgICAgIGN1c3RvbVVuaWZvcm1WYWx1ZXM/OiBudW1iZXJbXVtdLCBwcmV2ZW50RWFnZXJVbnBhY2tpbmdPZk91dHB1dCA9IGZhbHNlLFxuICAgICAgY3VzdG9tVGV4U2hhcGU/OiBbbnVtYmVyLCBudW1iZXJdKTogVGVuc29ySW5mbyB7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5tYWtlVGVuc29ySW5mbyhwcm9ncmFtLm91dHB1dFNoYXBlLCBvdXRwdXREdHlwZSk7XG4gICAgY29uc3Qgb3V0RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQob3V0cHV0LmRhdGFJZCk7XG4gICAgaWYgKHByb2dyYW0ucGFja2VkT3V0cHV0KSB7XG4gICAgICBvdXREYXRhLmlzUGFja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0ub3V0UGFja2luZ1NjaGVtZSA9PT0gdGV4X3V0aWwuUGFja2luZ1NjaGVtZS5ERU5TRSkge1xuICAgICAgY29uc3QgdGV4ZWxTaGFwZSA9IGN1c3RvbVRleFNoYXBlICE9IG51bGwgP1xuICAgICAgICAgIGN1c3RvbVRleFNoYXBlIDpcbiAgICAgICAgICB0ZXhfdXRpbC5nZXREZW5zZVRleFNoYXBlKHByb2dyYW0ub3V0cHV0U2hhcGUpO1xuICAgICAgLy8gRm9yIGEgZGVuc2VseSBwYWNrZWQgb3V0cHV0LCB3ZSBleHBsaWNpdGx5IHNldCB0ZXhTaGFwZVxuICAgICAgLy8gc28gaXQgZG9lc24ndCBnZXQgYXNzaWduZWQgbGF0ZXIgYWNjb3JkaW5nIHRvIG91ciB0eXBpY2FsIHBhY2tpbmdcbiAgICAgIC8vIHNjaGVtZSB3aGVyZWluIGEgc2luZ2xlIHRleGVsIGNhbiBvbmx5IGNvbnRhaW4gdmFsdWVzIGZyb20gYWRqYWNlbnRcbiAgICAgIC8vIHJvd3MvY29scy5cbiAgICAgIG91dERhdGEudGV4U2hhcGUgPSB0ZXhlbFNoYXBlLm1hcChkID0+IGQgKiAyKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5vdXRUZXhVc2FnZSAhPSBudWxsKSB7XG4gICAgICBvdXREYXRhLnVzYWdlID0gcHJvZ3JhbS5vdXRUZXhVc2FnZTtcbiAgICB9XG5cbiAgICBpZiAodXRpbC5zaXplRnJvbVNoYXBlKG91dHB1dC5zaGFwZSkgPT09IDApIHtcbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgdGhlIGNvbXB1dGF0aW9uIHNpbmNlIHRoZSByZXN1bHQgaXMgZW1wdHkgKGhhcyAwIGluIGl0c1xuICAgICAgLy8gc2hhcGUpLlxuICAgICAgb3V0RGF0YS52YWx1ZXMgPVxuICAgICAgICAgIHV0aWwuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShvdXRwdXQuZHR5cGUgYXMgJ2Zsb2F0MzInLCAwKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YVRvRGlzcG9zZTogVGVuc29ySW5mb1tdID0gW107XG4gICAgY29uc3QgaW5wdXRzRGF0YTogVGVuc29yRGF0YVtdID0gaW5wdXRzLm1hcChpbnB1dCA9PiB7XG4gICAgICBpZiAoaW5wdXQuZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgYCArXG4gICAgICAgICAgICBgZHR5cGVzLCBwbGVhc2Ugc2VwYXJhdGUgdGhlIHByb2dyYW0gaW50byByZWFsIGFuZCBpbWFnaW5hcnkgYCArXG4gICAgICAgICAgICBgcGFydHMuYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuXG4gICAgICBpZiAodGV4RGF0YS50ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgaWYgKCFwcm9ncmFtLnBhY2tlZElucHV0cyAmJlxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKGlucHV0LnNoYXBlKSA8PVxuICAgICAgICAgICAgICAgIGVudigpLmdldE51bWJlcignV0VCR0xfU0laRV9VUExPQURfVU5JRk9STScpKSB7XG4gICAgICAgICAgLy8gVXBsb2FkIHNtYWxsIHRlbnNvcnMgdGhhdCBsaXZlIG9uIHRoZSBDUFUgYXMgdW5pZm9ybXMsIG5vdCBhc1xuICAgICAgICAgIC8vIHRleHR1cmVzLiBEbyB0aGlzIG9ubHkgd2hlbiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgMzJiaXQgZmxvYXRzXG4gICAgICAgICAgLy8gZHVlIHRvIHByb2JsZW1zIHdoZW4gY29tcGFyaW5nIDE2Yml0IGZsb2F0cyB3aXRoIDMyYml0IGZsb2F0cy5cbiAgICAgICAgICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzgyMSk6IE1ha2UgaXRcbiAgICAgICAgICAvLyBwb3NzaWJsZSBmb3IgcGFja2VkIHNoYWRlcnMgdG8gc2FtcGxlIGZyb20gdW5pZm9ybXMuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNoYXBlOiBpbnB1dC5zaGFwZSxcbiAgICAgICAgICAgIHRleERhdGE6IG51bGwsXG4gICAgICAgICAgICBpc1VuaWZvcm06IHRydWUsXG4gICAgICAgICAgICB1bmlmb3JtVmFsdWVzOiB0ZXhEYXRhLnZhbHVlcyBhcyBUeXBlZEFycmF5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIGEgcGFja2VkIHByb2dyYW0ncyBpbnB1dHMgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAgICAgLy8gdXBsb2FkZWQgdG8gdGhlIEdQVSwgdGhleSBnZXQgdXBsb2FkZWQgYXMgcGFja2VkIHJpZ2h0IG9mZiB0aGUgYmF0LlxuICAgICAgICBpZiAocHJvZ3JhbS5wYWNrZWRJbnB1dHMpIHtcbiAgICAgICAgICB0ZXhEYXRhLmlzUGFja2VkID0gdHJ1ZTtcbiAgICAgICAgICB0ZXhEYXRhLnNoYXBlID0gaW5wdXQuc2hhcGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGxvYWRUb0dQVShpbnB1dC5kYXRhSWQpO1xuICAgICAgaWYgKCEhdGV4RGF0YS5pc1BhY2tlZCAhPT0gISFwcm9ncmFtLnBhY2tlZElucHV0cykge1xuICAgICAgICBpbnB1dCA9IHRleERhdGEuaXNQYWNrZWQgPyB0aGlzLnVucGFja1RlbnNvcihpbnB1dCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tUZW5zb3IoaW5wdXQpO1xuICAgICAgICBkYXRhVG9EaXNwb3NlLnB1c2goaW5wdXQpO1xuICAgICAgICB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0ZXhEYXRhLmlzUGFja2VkICYmXG4gICAgICAgICAgIXdlYmdsX3V0aWwuaXNSZXNoYXBlRnJlZSh0ZXhEYXRhLnNoYXBlLCBpbnB1dC5zaGFwZSkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSBhIHRleHR1cmUgZXhpc3RzIGZvciBhIHRlbnNvclxuICAgICAgICAvLyBidXQgdGhlIHNoYXBlcyBhcmUgaW5jb21wYXRpYmxlIChkdWUgdG8gcGFja2luZyBjb25zdHJhaW50cykgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgdGVuc29yIGRpZCBub3QgaGF2ZSBhIGNoYW5jZSB0byBnbyB0aHJvdWdoIHRoZSBwYWNrZWQgcmVzaGFwZVxuICAgICAgICAvLyBzaGFkZXIuIFRoaXMgb25seSBoYXBwZW5zIHdoZW4gd2UgcmVzaGFwZSB0aGUgKnNhbWUqIHRlbnNvciB0byBmb3JtXG4gICAgICAgIC8vICpkaXN0aW5jdCogaW5wdXRzIHRvIGFuIG9wLCBlLmcuIGRvdHRpbmcgYSB2ZWN0b3Igd2l0aCBpdHNlbGYuIFRoaXNcbiAgICAgICAgLy8gY2FzZSB3aWxsIGRpc2FwcGVhciBvbmNlIHBhY2tlZCB1cGxvYWRpbmcgaXMgdGhlIGRlZmF1bHQuXG5cbiAgICAgICAgY29uc3Qgc2F2ZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICBjb25zdCB0YXJnZXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuXG4gICAgICAgIGlucHV0LnNoYXBlID0gdGV4RGF0YS5zaGFwZTtcbiAgICAgICAgaW5wdXQgPSB0aGlzLnBhY2tlZFJlc2hhcGUoaW5wdXQgYXMgVGVuc29yLCB0YXJnZXRTaGFwZSk7XG4gICAgICAgIGRhdGFUb0Rpc3Bvc2UucHVzaChpbnB1dCk7XG4gICAgICAgIHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGlucHV0LmRhdGFJZCk7XG5cbiAgICAgICAgc2F2ZWRJbnB1dC5zaGFwZSA9IHRhcmdldFNoYXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge3NoYXBlOiBpbnB1dC5zaGFwZSwgdGV4RGF0YSwgaXNVbmlmb3JtOiBmYWxzZX07XG4gICAgfSk7XG5cbiAgICB0aGlzLnVwbG9hZFRvR1BVKG91dHB1dC5kYXRhSWQpO1xuICAgIGNvbnN0IG91dHB1dERhdGE6XG4gICAgICAgIFRlbnNvckRhdGEgPSB7c2hhcGU6IG91dHB1dC5zaGFwZSwgdGV4RGF0YTogb3V0RGF0YSwgaXNVbmlmb3JtOiBmYWxzZX07XG4gICAgY29uc3Qga2V5ID0gZ3BncHVfbWF0aC5tYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0c0RhdGEsIG91dHB1dERhdGEpO1xuICAgIGNvbnN0IGJpbmFyeSA9IHRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShrZXksICgpID0+IHtcbiAgICAgIHJldHVybiBncGdwdV9tYXRoLmNvbXBpbGVQcm9ncmFtKFxuICAgICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIGlucHV0c0RhdGEsIG91dHB1dERhdGEpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNob3VsZFRpbWVQcm9ncmFtID0gdGhpcy5hY3RpdmVUaW1lcnMgIT0gbnVsbDtcbiAgICBsZXQgcXVlcnk6IFdlYkdMUXVlcnl8Q1BVVGltZXJRdWVyeTtcbiAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5zdGFydFRpbWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKCFlbnYoKS5nZXQoJ0VOR0lORV9DT01QSUxFX09OTFknKSkge1xuICAgICAgZ3BncHVfbWF0aC5ydW5Qcm9ncmFtKFxuICAgICAgICAgIHRoaXMuZ3BncHUsIGJpbmFyeSwgaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSwgY3VzdG9tVW5pZm9ybVZhbHVlcyk7XG4gICAgfVxuXG4gICAgZGF0YVRvRGlzcG9zZS5mb3JFYWNoKGluZm8gPT4gdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpbmZvKSk7XG5cbiAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5lbmRUaW1lcihxdWVyeSk7XG4gICAgICB0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKFxuICAgICAgICAgIHtuYW1lOiBwcm9ncmFtLmNvbnN0cnVjdG9yLm5hbWUsIHF1ZXJ5OiB0aGlzLmdldFF1ZXJ5VGltZShxdWVyeSl9KTtcbiAgICB9XG5cbiAgICBjb25zdCBnbEZsdXNoVGhyZXNob2xkID0gZW52KCkuZ2V0KCdXRUJHTF9GTFVTSF9USFJFU0hPTEQnKTtcbiAgICAvLyBNYW51YWxseSBHTCBmbHVzaCByZXF1ZXN0ZWRcbiAgICBpZiAoZ2xGbHVzaFRocmVzaG9sZCA+IDApIHtcbiAgICAgIGNvbnN0IHRpbWUgPSB1dGlsLm5vdygpO1xuICAgICAgaWYgKCh0aW1lIC0gdGhpcy5sYXN0R2xGbHVzaFRpbWUpID4gZ2xGbHVzaFRocmVzaG9sZCkge1xuICAgICAgICB0aGlzLmdwZ3B1LmdsLmZsdXNoKCk7XG4gICAgICAgIHRoaXMubGFzdEdsRmx1c2hUaW1lID0gdGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWVudigpLmdldEJvb2woJ1dFQkdMX0xBWklMWV9VTlBBQ0snKSAmJiBvdXREYXRhLmlzUGFja2VkICYmXG4gICAgICAgIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgdW5wYWNrZWQgPSB0aGlzLnVucGFja1RlbnNvcihvdXRwdXQpO1xuICAgICAgdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvdXRwdXQpO1xuICAgICAgcmV0dXJuIHVucGFja2VkO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgY29tcGlsZUFuZFJ1bihcbiAgICAgIHByb2dyYW06IEdQR1BVUHJvZ3JhbSwgaW5wdXRzOiBUZW5zb3JJbmZvW10sIG91dHB1dER0eXBlPzogRGF0YVR5cGUsXG4gICAgICBjdXN0b21Vbmlmb3JtVmFsdWVzPzogbnVtYmVyW11bXSxcbiAgICAgIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0ID0gZmFsc2UpOiBUZW5zb3JJbmZvIHtcbiAgICBvdXRwdXREdHlwZSA9IG91dHB1dER0eXBlIHx8IGlucHV0c1swXS5kdHlwZTtcbiAgICBjb25zdCBvdXRJbmZvID0gdGhpcy5ydW5XZWJHTFByb2dyYW0oXG4gICAgICAgIHByb2dyYW0sIGlucHV0cywgb3V0cHV0RHR5cGUsIGN1c3RvbVVuaWZvcm1WYWx1ZXMsXG4gICAgICAgIHByZXZlbnRFYWdlclVucGFja2luZ09mT3V0cHV0KTtcbiAgICByZXR1cm4gb3V0SW5mbztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QW5kU2F2ZUJpbmFyeShrZXk6IHN0cmluZywgZ2V0QmluYXJ5OiAoKSA9PiBHUEdQVUJpbmFyeSk6XG4gICAgICBHUEdQVUJpbmFyeSB7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICB0aGlzLmJpbmFyeUNhY2hlW2tleV0gPSBnZXRCaW5hcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5Q2FjaGVba2V5XTtcbiAgfVxuXG4gIGdldFRleHR1cmVNYW5hZ2VyKCk6IFRleHR1cmVNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcjtcbiAgfVxuXG4gIHByaXZhdGUgZGlzcG9zZWQgPSBmYWxzZTtcblxuICBvdmVycmlkZSBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEF2b2lkIGRpc3Bvc2luZyB0aGUgY29tcGlsZWQgd2ViZ2wgcHJvZ3JhbXMgZHVyaW5nIHVuaXQgdGVzdGluZyBiZWNhdXNlXG4gICAgLy8gaXQgc2xvd3MgZG93biB0ZXN0IGV4ZWN1dGlvbi5cbiAgICBpZiAoIWVudigpLmdldEJvb2woJ0lTX1RFU1QnKSkge1xuICAgICAgY29uc3QgYWxsS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuYmluYXJ5Q2FjaGUpO1xuICAgICAgYWxsS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHRoaXMuZ3BncHUuZGVsZXRlUHJvZ3JhbSh0aGlzLmJpbmFyeUNhY2hlW2tleV0ud2ViR0xQcm9ncmFtKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYmluYXJ5Q2FjaGVba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICBpZiAodGhpcy5jYW52YXMgIT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIChIVE1MQ2FudmFzRWxlbWVudCkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB0aGlzLmNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSkge1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSkge1xuICAgICAgdGhpcy5ncGdwdS5wcm9ncmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZ3BncHUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIG92ZXJyaWRlIGZsb2F0UHJlY2lzaW9uKCk6IDE2fDMyIHtcbiAgICBpZiAodGhpcy5mbG9hdFByZWNpc2lvblZhbHVlID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZSA9IHRpZHkoKCkgPT4ge1xuICAgICAgICBpZiAoIWVudigpLmdldCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcpKSB7XG4gICAgICAgICAgLy8gTW9tZW50YXJpbHkgc3dpdGNoaW5nIERFQlVHIGZsYWcgdG8gZmFsc2Ugc28gd2UgZG9uJ3QgdGhyb3cgYW5cbiAgICAgICAgICAvLyBlcnJvciB0cnlpbmcgdG8gdXBsb2FkIGEgc21hbGwgdmFsdWUuXG4gICAgICAgICAgY29uc3QgZGVidWdGbGFnID0gZW52KCkuZ2V0Qm9vbCgnREVCVUcnKTtcbiAgICAgICAgICBlbnYoKS5zZXQoJ0RFQlVHJywgZmFsc2UpO1xuICAgICAgICAgIGNvbnN0IHVuZGVyZmxvd0NoZWNrVmFsdWUgPSB0aGlzLmFicyhzY2FsYXIoMWUtOCkpLmRhdGFTeW5jKClbMF07XG4gICAgICAgICAgZW52KCkuc2V0KCdERUJVRycsIGRlYnVnRmxhZyk7XG5cbiAgICAgICAgICBpZiAodW5kZXJmbG93Q2hlY2tWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSBudW1iZXIuICAqL1xuICBvdmVycmlkZSBlcHNpbG9uKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZmxvYXRQcmVjaXNpb24oKSA9PT0gMzIgPyBFUFNJTE9OX0ZMT0FUMzIgOiBFUFNJTE9OX0ZMT0FUMTY7XG4gIH1cblxuICB1cGxvYWRUb0dQVShkYXRhSWQ6IERhdGFJZCk6IHZvaWQge1xuICAgIGNvbnN0IHRleERhdGEgPSB0aGlzLnRleERhdGEuZ2V0KGRhdGFJZCk7XG4gICAgY29uc3Qge3NoYXBlLCBkdHlwZSwgdmFsdWVzLCB0ZXh0dXJlLCB1c2FnZSwgaXNQYWNrZWR9ID0gdGV4RGF0YTtcblxuICAgIGlmICh0ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgIC8vIEFycmF5IGlzIGFscmVhZHkgb24gR1BVLiBOby1vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkVGltZVByb2dyYW0gPSB0aGlzLmFjdGl2ZVRpbWVycyAhPSBudWxsO1xuICAgIGxldCBzdGFydDogbnVtYmVyO1xuICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgc3RhcnQgPSB1dGlsLm5vdygpO1xuICAgIH1cblxuICAgIGxldCB0ZXhTaGFwZSA9IHRleERhdGEudGV4U2hhcGU7XG4gICAgaWYgKHRleFNoYXBlID09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgdGV4U2hhcGUgbWF5IG5vdCBiZSB0aGUgZmluYWwgdGV4dHVyZSBzaGFwZS4gRm9yIHBhY2tlZCBvciBkZW5zZVxuICAgICAgLy8gdGV4dHVyZXMsIHRoZSB0ZXhTaGFwZSB3aWxsIGJlIGNoYW5nZWQgd2hlbiB0ZXh0dXJlcyBhcmUgY3JlYXRlZC5cbiAgICAgIHRleFNoYXBlID0gd2ViZ2xfdXRpbC5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKHNoYXBlLCBpc1BhY2tlZCk7XG4gICAgICB0ZXhEYXRhLnRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzaGFwZUFzM0QgPSB3ZWJnbF91dGlsLmdldFNoYXBlQXMzRChzaGFwZSk7XG5cbiAgICAgIGxldCBwcm9ncmFtO1xuICAgICAgbGV0IHdpZHRoID0gdGV4U2hhcGVbMV0sIGhlaWdodCA9IHRleFNoYXBlWzBdO1xuICAgICAgY29uc3QgaXNCeXRlQXJyYXkgPVxuICAgICAgICAgIHZhbHVlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWVzIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXk7XG5cbiAgICAgIC8vIHRleHR1cmUgZm9yIGZsb2F0IGFycmF5IGlzIFBoeXNpY2FsVGV4dHVyZVR5cGUuUEFDS0VEXzJYMl9GTE9BVDMyLCB3ZVxuICAgICAgLy8gbmVlZCB0byBtYWtlIHN1cmUgdGhlIHVwbG9hZCB1c2VzIHRoZSBzYW1lIHBhY2tlZCBzaXplXG4gICAgICBpZiAoaXNQYWNrZWQgfHwgIWlzQnl0ZUFycmF5KSB7XG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KFxuICAgICAgICAgICAgdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgRW5jb2RlTWF0cml4UGFja2VkUHJvZ3JhbShzaGFwZUFzM0QsIGlzQnl0ZUFycmF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgRW5jb2RlTWF0cml4UHJvZ3JhbShzaGFwZUFzM0QsIGlzQnl0ZUFycmF5KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGV4U2hhcGUgZm9yIGZsb2F0IGFycmF5IG5lZWRzIHRvIGJlIHRoZSBvcmlnaW5hbCBzaGFwZSwgd2hpY2ggYnl0ZVxuICAgICAgLy8gYXJyYXkgbmVlZHMgdG8gYmUgcGFja2VkIHNpemUuIFRoaXMgYWxsb3cgdGhlIGRhdGEgdXBsb2FkIHNoYXBlIHRvIGJlXG4gICAgICAvLyBtYXRjaGVkIHdpdGggdGV4dHVyZSBjcmVhdGlvbiBsb2dpYy5cbiAgICAgIGNvbnN0IHRlbXBEZW5zZUlucHV0VGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICAgIGlzQnl0ZUFycmF5ID8gW2hlaWdodCwgd2lkdGhdIDogdGV4U2hhcGU7XG4gICAgICBjb25zdCB0ZW1wRGVuc2VJbnB1dEhhbmRsZSA9XG4gICAgICAgICAgdGhpcy5tYWtlVGVuc29ySW5mbyh0ZW1wRGVuc2VJbnB1dFRleFNoYXBlLCBkdHlwZSk7XG4gICAgICBjb25zdCB0ZW1wRGVuc2VJbnB1dFRleERhdGEgPVxuICAgICAgICAgIHRoaXMudGV4RGF0YS5nZXQodGVtcERlbnNlSW5wdXRIYW5kbGUuZGF0YUlkKTtcbiAgICAgIGlmIChpc0J5dGVBcnJheSkge1xuICAgICAgICB0ZW1wRGVuc2VJbnB1dFRleERhdGEudXNhZ2UgPSBUZXh0dXJlVXNhZ2UuUElYRUxTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcERlbnNlSW5wdXRUZXhEYXRhLnVzYWdlID0gVGV4dHVyZVVzYWdlLlVQTE9BRDtcbiAgICAgIH1cbiAgICAgIHRlbXBEZW5zZUlucHV0VGV4RGF0YS50ZXhTaGFwZSA9IHRlbXBEZW5zZUlucHV0VGV4U2hhcGU7XG4gICAgICB0aGlzLmdwZ3B1LnVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZ2V0VGV4dHVyZSh0ZW1wRGVuc2VJbnB1dEhhbmRsZS5kYXRhSWQpLCB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIHZhbHVlcyBhcyBUeXBlZEFycmF5KTtcblxuICAgICAgY29uc3QgY3VzdG9tVmFsdWVzID0gW1toZWlnaHQsIHdpZHRoXV07XG4gICAgICAvLyBXZSB3YW50IHRoZSBvdXRwdXQgdG8gcmVtYWluIHBhY2tlZCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZlxuICAgICAgLy8gV0VCR0xfUEFDSy5cbiAgICAgIGNvbnN0IHByZXZlbnRFYWdlclVucGFja2luZyA9IHRydWU7XG4gICAgICBjb25zdCBlbmNvZGVkT3V0cHV0VGFyZ2V0ID0gdGhpcy5ydW5XZWJHTFByb2dyYW0oXG4gICAgICAgICAgcHJvZ3JhbSwgW3RlbXBEZW5zZUlucHV0SGFuZGxlXSwgZHR5cGUsIGN1c3RvbVZhbHVlcyxcbiAgICAgICAgICBwcmV2ZW50RWFnZXJVbnBhY2tpbmcpO1xuXG4gICAgICAvLyBIYXZlIHRoZSBvcmlnaW5hbCB0ZXh0dXJlIGFzc3VtZSB0aGUgaWRlbnRpdHkgb2YgdGhlIGVuY29kZWQgb3V0cHV0LlxuICAgICAgY29uc3Qgb3V0cHV0VGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZW5jb2RlZE91dHB1dFRhcmdldC5kYXRhSWQpO1xuICAgICAgdGV4RGF0YS50ZXhTaGFwZSA9IG91dHB1dFRleERhdGEudGV4U2hhcGU7XG4gICAgICB0ZXhEYXRhLmlzUGFja2VkID0gb3V0cHV0VGV4RGF0YS5pc1BhY2tlZDtcbiAgICAgIHRleERhdGEudXNhZ2UgPSBvdXRwdXRUZXhEYXRhLnVzYWdlO1xuXG4gICAgICBpZiAoIWVudigpLmdldCgnRU5HSU5FX0NPTVBJTEVfT05MWScpKSB7XG4gICAgICAgIHRleERhdGEudGV4dHVyZSA9IG91dHB1dFRleERhdGEudGV4dHVyZTtcbiAgICAgICAgLy8gT25jZSB1cGxvYWRlZCwgZG9uJ3Qgc3RvcmUgdGhlIHZhbHVlcyBvbiBjcHUuXG4gICAgICAgIHRleERhdGEudmFsdWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXhEYXRhLmRlbGV0ZShlbmNvZGVkT3V0cHV0VGFyZ2V0LmRhdGFJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3Bvc2VEYXRhKGVuY29kZWRPdXRwdXRUYXJnZXQuZGF0YUlkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh0ZW1wRGVuc2VJbnB1dEhhbmRsZSk7XG5cbiAgICAgIGlmIChzaG91bGRUaW1lUHJvZ3JhbSkge1xuICAgICAgICB0aGlzLnVwbG9hZFdhaXRNcyArPSB1dGlsLm5vdygpIC0gc3RhcnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld1RleHR1cmUgPSB0aGlzLmFjcXVpcmVUZXh0dXJlKHRleFNoYXBlLCB1c2FnZSwgZHR5cGUsIGlzUGFja2VkKTtcbiAgICAgIHRleERhdGEudGV4dHVyZSA9IG5ld1RleHR1cmU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb252ZXJ0QW5kQ2FjaGVPbkNQVShkYXRhSWQ6IERhdGFJZCwgZmxvYXQzMlZhbHVlcz86IEZsb2F0MzJBcnJheSk6XG4gICAgICBUeXBlZEFycmF5IHtcbiAgICBjb25zdCB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgIGNvbnN0IHtkdHlwZX0gPSB0ZXhEYXRhO1xuXG4gICAgaWYgKGZsb2F0MzJWYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGV4RGF0YS52YWx1ZXMgPSBmbG9hdDMyVG9UeXBlZEFycmF5KGZsb2F0MzJWYWx1ZXMsIGR0eXBlIGFzICdmbG9hdDMyJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZXhEYXRhLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuICB9XG5cbiAgcHJpdmF0ZSBhY3F1aXJlVGV4dHVyZShcbiAgICAgIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB0ZXhUeXBlOiBUZXh0dXJlVXNhZ2UsIGR0eXBlOiBEYXRhVHlwZSxcbiAgICAgIGlzUGFja2VkOiBib29sZWFuKTogVGV4dHVyZSB7XG4gICAgdGhpcy5udW1CeXRlc0luR1BVICs9IHRoaXMuY29tcHV0ZUJ5dGVzKHRleFNoYXBlLCBkdHlwZSk7XG4gICAgaWYgKCF0aGlzLndhcm5lZEFib3V0TWVtb3J5ICYmXG4gICAgICAgIHRoaXMubnVtQnl0ZXNJbkdQVSA+IHRoaXMubnVtTUJCZWZvcmVXYXJuaW5nICogMTAyNCAqIDEwMjQpIHtcbiAgICAgIGNvbnN0IG1iID0gKHRoaXMubnVtQnl0ZXNJbkdQVSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpO1xuICAgICAgdGhpcy53YXJuZWRBYm91dE1lbW9yeSA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYEhpZ2ggbWVtb3J5IHVzYWdlIGluIEdQVTogJHttYn0gTUIsIGAgK1xuICAgICAgICAgIGBtb3N0IGxpa2VseSBkdWUgdG8gYSBtZW1vcnkgbGVha2ApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXhTaGFwZSwgdGV4VHlwZSwgaXNQYWNrZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlQnl0ZXMoc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIGR0eXBlOiBEYXRhVHlwZSkge1xuICAgIHJldHVybiBzaGFwZVswXSAqIHNoYXBlWzFdICogdXRpbC5ieXRlc1BlckVsZW1lbnQoZHR5cGUpO1xuICB9XG5cbiAgY2hlY2tDb21waWxlQ29tcGxldGlvbigpIHtcbiAgICBmb3IgKGNvbnN0IFssIGJpbmFyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5iaW5hcnlDYWNoZSkpIHtcbiAgICAgIHRoaXMuY2hlY2tDb21wbGV0aW9uXyhiaW5hcnkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNoZWNrQ29tcGlsZUNvbXBsZXRpb25Bc3luYygpOiBQcm9taXNlPGJvb2xlYW5bXT4ge1xuICAgIGNvbnN0IHBzID0gW107XG4gICAgaWYgKHRoaXMuZ3BncHUucGFyYWxsZWxDb21waWxhdGlvbkV4dGVuc2lvbikge1xuICAgICAgZm9yIChjb25zdCBbLCBiaW5hcnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICAgIHBzLnB1c2godGhpcy5jaGVja0NvbXBsZXRpb25Bc3luY18oYmluYXJ5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGJpbmFyeV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5iaW5hcnlDYWNoZSkpIHtcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxib29sZWFuPiA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb21wbGV0aW9uXyhiaW5hcnkpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0NvbXBsZXRpb25Bc3luY18oYmluYXJ5OiBHUEdQVUJpbmFyeSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICh0aGlzLmdwZ3B1LmdsLmdldFByb2dyYW1QYXJhbWV0ZXIoXG4gICAgICAgICAgICBiaW5hcnkud2ViR0xQcm9ncmFtLFxuICAgICAgICAgICAgdGhpcy5ncGdwdS5wYXJhbGxlbENvbXBpbGF0aW9uRXh0ZW5zaW9uLkNPTVBMRVRJT05fU1RBVFVTX0tIUikpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrQ29tcGxldGlvbl8oYmluYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgbmV4dEZyYW1lKCk7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0NvbXBsZXRpb25Bc3luY18oYmluYXJ5KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrQ29tcGxldGlvbl8oYmluYXJ5OiBHUEdQVUJpbmFyeSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmdwZ3B1LmdsLmdldFByb2dyYW1QYXJhbWV0ZXIoXG4gICAgICAgICAgICBiaW5hcnkud2ViR0xQcm9ncmFtLCB0aGlzLmdwZ3B1LmdsLkxJTktfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ3BncHUuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coYmluYXJ5LndlYkdMUHJvZ3JhbSkpO1xuICAgICAgaWYgKHRoaXMuZ3BncHUuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKFxuICAgICAgICAgICAgICBiaW5hcnkuZnJhZ21lbnRTaGFkZXIsIHRoaXMuZ3BncHUuZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICB3ZWJnbF91dGlsLmxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2coXG4gICAgICAgICAgICBiaW5hcnkuc291cmNlLFxuICAgICAgICAgICAgdGhpcy5ncGdwdS5nbC5nZXRTaGFkZXJJbmZvTG9nKGJpbmFyeS5mcmFnbWVudFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci4nKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLicpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldFVuaWZvcm1Mb2NhdGlvbnMoKSB7XG4gICAgZm9yIChjb25zdCBbLCBiaW5hcnldIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgICAgIGN1c3RvbVVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgICAgIGluZkxvYyxcbiAgICAgICAgbmFuTG9jLFxuICAgICAgICBpblNoYXBlc0xvY2F0aW9ucyxcbiAgICAgICAgaW5UZXhTaGFwZXNMb2NhdGlvbnMsXG4gICAgICAgIG91dFNoYXBlTG9jYXRpb24sXG4gICAgICAgIG91dFNoYXBlU3RyaWRlc0xvY2F0aW9uLFxuICAgICAgICBvdXRUZXhTaGFwZUxvY2F0aW9uXG4gICAgICB9ID0gZ2V0VW5pZm9ybUxvY2F0aW9ucyh0aGlzLmdwZ3B1LCBiaW5hcnkucHJvZ3JhbSwgYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgICBiaW5hcnkudW5pZm9ybUxvY2F0aW9ucyA9IHVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICBiaW5hcnkuY3VzdG9tVW5pZm9ybUxvY2F0aW9ucyA9IGN1c3RvbVVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICBiaW5hcnkuaW5mTG9jID0gaW5mTG9jO1xuICAgICAgYmluYXJ5Lm5hbkxvYyA9IG5hbkxvYztcbiAgICAgIGJpbmFyeS5pblNoYXBlc0xvY2F0aW9ucyA9IGluU2hhcGVzTG9jYXRpb25zO1xuICAgICAgYmluYXJ5LmluVGV4U2hhcGVzTG9jYXRpb25zID0gaW5UZXhTaGFwZXNMb2NhdGlvbnM7XG4gICAgICBiaW5hcnkub3V0U2hhcGVMb2NhdGlvbiA9IG91dFNoYXBlTG9jYXRpb247XG4gICAgICBiaW5hcnkub3V0U2hhcGVTdHJpZGVzTG9jYXRpb24gPSBvdXRTaGFwZVN0cmlkZXNMb2NhdGlvbjtcbiAgICAgIGJpbmFyeS5vdXRUZXhTaGFwZUxvY2F0aW9uID0gb3V0VGV4U2hhcGVMb2NhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVEYuanMgdGVuc29yIG91dCBvZiBhbiBleGlzdGluZyBXZWJHTCB0ZXh0dXJlLiBBIG5ldyB0ZXh0dXJlIHdpbGxcbiAgICogYmUgY3JlYXRlZC5cbiAgICovXG4gIG92ZXJyaWRlIGNyZWF0ZVRlbnNvckZyb21UZXh0dXJlKHZhbHVlczogV2ViR0xEYXRhLCBzaGFwZTogbnVtYmVyW10sXG4gICAgICBkdHlwZTogRGF0YVR5cGUpOiBUZW5zb3Ige1xuICAgIGNvbnN0IHt0ZXh0dXJlLCBoZWlnaHQsIHdpZHRoLCBjaGFubmVsc30gPSB2YWx1ZXM7XG4gICAgY29uc3QgYmFja2VuZCA9IGVuZ2luZSgpLmJhY2tlbmQgYXMgTWF0aEJhY2tlbmRXZWJHTDtcblxuICAgIC8vIEhhdmUgdG8gdGhyb3cgYW4gZXJyb3IsIG90aGVyd2lzZSBXZWJHTCBqdXN0IHdhcm5zIGFuZCByZXR1cm5zIHdyb25nXG4gICAgLy8gdmFsdWVzLlxuICAgIGlmICghYmFja2VuZC5ncGdwdS5nbC5pc1RleHR1cmUodGV4dHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVGhlIHRleHR1cmUgaXMgaW52YWxpZC4gQWxzbywgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgdGV4dHVyZSBhbmQgYCArXG4gICAgICAgICAgYHRoZSBURkpTIFdlYkdMIGJhY2tlbmQgYXJlIHVzaW5nIHRoZSBzYW1lIGNhbnZhcy4gSWYgeW91IHdhbnQgdG8gYCArXG4gICAgICAgICAgYHVzZSB5b3VyIG93biBjdXN0b20gY2FudmFzLCB5b3UgaGF2ZSB0byBjcmVhdGUgYW5kIHVzZSB0aGUgY3VzdG9tIGAgK1xuICAgICAgICAgIGBURkpTIFdlYkdMIGJhY2tlbmQgY3JlYXRlZCBmcm9tIHRoZSBjYW52YXMgdGhyb3VnaCBgICtcbiAgICAgICAgICBgJ25ldyB0Zi5NYXRoQmFja2VuZFdlYkdMKGN1c3RvbUNhbnZhcyknLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFJZCA9XG4gICAgICAgIGJhY2tlbmQud3JpdGVUZXh0dXJlKHRleHR1cmUsIHNoYXBlLCBkdHlwZSwgaGVpZ2h0LCB3aWR0aCwgY2hhbm5lbHMpO1xuICAgIHJldHVybiBlbmdpbmUoKS5tYWtlVGVuc29yRnJvbURhdGFJZChkYXRhSWQsIHNoYXBlLCBkdHlwZSwgYmFja2VuZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxvYXQzMlRvVHlwZWRBcnJheTxEIGV4dGVuZHMgTnVtZXJpY0RhdGFUeXBlPihcbiAgICBhOiBGbG9hdDMyQXJyYXksIGR0eXBlOiBEKTogdGYuRGF0YVR5cGVNYXBbRF0ge1xuICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJyB8fCBkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICByZXR1cm4gYSBhcyB0Zi5EYXRhVHlwZU1hcFtEXTtcbiAgfSBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJyB8fCBkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gKGR0eXBlID09PSAnaW50MzInKSA/IG5ldyBJbnQzMkFycmF5KGEubGVuZ3RoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCBhcyB0Zi5EYXRhVHlwZU1hcFtEXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZHR5cGUgJHtkdHlwZX1gKTtcbiAgfVxufVxuIl19