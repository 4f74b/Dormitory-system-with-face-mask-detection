/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { SparseToDense } from '../kernel_names';
import * as sparse_to_dense from '../ops/sparse_to_dense_util';
import { convertToTensor } from '../tensor_util_env';
import { assertNonNegativeIntegerDimensions } from '../util_base';
import { op } from './operation';
/**
 * Converts a sparse representation into a dense tensor.
 *
 * Builds an array dense with shape outputShape such that:
 *
 * // If sparseIndices is scalar
 * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)
 *
 * // If sparseIndices is a vector, then for each i
 * dense[sparseIndices[i]] = sparseValues[i]
 *
 * // If sparseIndices is an n by d matrix, then for each i in [0, n)
 * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]
 * All other values in dense are set to defaultValue. If sparseValues is a
 * scalar, all sparse indices are set to this single value.
 *
 * If indices are repeated the final value is summed over all values for those
 * indices.
 *
 * ```js
 * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');
 * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');
 * const shape = [8];
 * tf.sparseToDense(indices, values, shape).print();
 * ```
 *
 * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.
 * sparseIndices[i] contains the complete index where sparseValues[i] will be
 * placed.
 * @param sparseValues A 0-D or 1-D Tensor. Values
 * corresponding to each row of sparseIndices, or a scalar value to be used for
 * all sparse indices.
 * @param outputShape Shape of the dense output tensor. The type is inferred.
 * @param defaultValue Scalar. Value to set for indices not specified in
 * sparseIndices. Defaults to zero.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
    assertNonNegativeIntegerDimensions(outputShape);
    const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');
    const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense', 'string_or_numeric');
    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);
    sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);
    const inputs = {
        sparseIndices: $sparseIndices,
        sparseValues: $sparseValues,
        defaultValue: $defaultValue
    };
    const attrs = { outputShape };
    return ENGINE.runKernel(SparseToDense, inputs, attrs);
}
export const sparseToDense = op({ sparseToDense_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3RvX2RlbnNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc3BhcnNlX3RvX2RlbnNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakMsT0FBTyxFQUFDLGFBQWEsRUFBMEMsTUFBTSxpQkFBaUIsQ0FBQztBQUV2RixPQUFPLEtBQUssZUFBZSxNQUFNLDZCQUE2QixDQUFDO0FBRy9ELE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEUsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFDRztBQUNILFNBQVMsY0FBYyxDQUNuQixhQUFnQyxFQUFFLFlBQStCLEVBQ2pFLFdBQXdCLEVBQUUsZUFBa0MsQ0FBQztJQUMvRCxrQ0FBa0MsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUVoRCxNQUFNLGNBQWMsR0FDaEIsZUFBZSxDQUFDLGFBQWEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzlFLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FDakMsWUFBWSxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUN4RSxNQUFNLGFBQWEsR0FBRyxlQUFlLENBQ2pDLFlBQVksRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUV4RSxlQUFlLENBQUMsYUFBYSxDQUN6QixjQUFjLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUUvRCxNQUFNLE1BQU0sR0FBd0I7UUFDbEMsYUFBYSxFQUFFLGNBQWM7UUFDN0IsWUFBWSxFQUFFLGFBQWE7UUFDM0IsWUFBWSxFQUFFLGFBQWE7S0FDNUIsQ0FBQztJQUVGLE1BQU0sS0FBSyxHQUF1QixFQUFDLFdBQVcsRUFBQyxDQUFDO0lBRWhELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FDbkIsYUFBYSxFQUFFLE1BQThCLEVBQzdDLEtBQTJCLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQyxFQUFDLGNBQWMsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtTcGFyc2VUb0RlbnNlLCBTcGFyc2VUb0RlbnNlQXR0cnMsIFNwYXJzZVRvRGVuc2VJbnB1dHN9IGZyb20gJy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCAqIGFzIHNwYXJzZV90b19kZW5zZSBmcm9tICcuLi9vcHMvc3BhcnNlX3RvX2RlbnNlX3V0aWwnO1xuaW1wb3J0IHtTY2FsYXIsIFRlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7UmFuaywgU2NhbGFyTGlrZSwgU2hhcGVNYXAsIFRlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7YXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9uc30gZnJvbSAnLi4vdXRpbF9iYXNlJztcblxuaW1wb3J0IHtvcH0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3BhcnNlIHJlcHJlc2VudGF0aW9uIGludG8gYSBkZW5zZSB0ZW5zb3IuXG4gKlxuICogQnVpbGRzIGFuIGFycmF5IGRlbnNlIHdpdGggc2hhcGUgb3V0cHV0U2hhcGUgc3VjaCB0aGF0OlxuICpcbiAqIC8vIElmIHNwYXJzZUluZGljZXMgaXMgc2NhbGFyXG4gKiBkZW5zZVtpXSA9IChpID09IHNwYXJzZUluZGljZXMgPyBzcGFyc2VWYWx1ZXMgOiBkZWZhdWx0VmFsdWUpXG4gKlxuICogLy8gSWYgc3BhcnNlSW5kaWNlcyBpcyBhIHZlY3RvciwgdGhlbiBmb3IgZWFjaCBpXG4gKiBkZW5zZVtzcGFyc2VJbmRpY2VzW2ldXSA9IHNwYXJzZVZhbHVlc1tpXVxuICpcbiAqIC8vIElmIHNwYXJzZUluZGljZXMgaXMgYW4gbiBieSBkIG1hdHJpeCwgdGhlbiBmb3IgZWFjaCBpIGluIFswLCBuKVxuICogZGVuc2Vbc3BhcnNlSW5kaWNlc1tpXVswXSwgLi4uLCBzcGFyc2VJbmRpY2VzW2ldW2QtMV1dID0gc3BhcnNlVmFsdWVzW2ldXG4gKiBBbGwgb3RoZXIgdmFsdWVzIGluIGRlbnNlIGFyZSBzZXQgdG8gZGVmYXVsdFZhbHVlLiBJZiBzcGFyc2VWYWx1ZXMgaXMgYVxuICogc2NhbGFyLCBhbGwgc3BhcnNlIGluZGljZXMgYXJlIHNldCB0byB0aGlzIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBJZiBpbmRpY2VzIGFyZSByZXBlYXRlZCB0aGUgZmluYWwgdmFsdWUgaXMgc3VtbWVkIG92ZXIgYWxsIHZhbHVlcyBmb3IgdGhvc2VcbiAqIGluZGljZXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGluZGljZXMgPSB0Zi50ZW5zb3IxZChbNCwgNSwgNiwgMSwgMiwgM10sICdpbnQzMicpO1xuICogY29uc3QgdmFsdWVzID0gdGYudGVuc29yMWQoWzEwLCAxMSwgMTIsIDEzLCAxNCwgMTVdLCAnZmxvYXQzMicpO1xuICogY29uc3Qgc2hhcGUgPSBbOF07XG4gKiB0Zi5zcGFyc2VUb0RlbnNlKGluZGljZXMsIHZhbHVlcywgc2hhcGUpLnByaW50KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3BhcnNlSW5kaWNlcyBBIDAtRCwgMS1ELCBvciAyLUQgVGVuc29yIG9mIHR5cGUgaW50MzIuXG4gKiBzcGFyc2VJbmRpY2VzW2ldIGNvbnRhaW5zIHRoZSBjb21wbGV0ZSBpbmRleCB3aGVyZSBzcGFyc2VWYWx1ZXNbaV0gd2lsbCBiZVxuICogcGxhY2VkLlxuICogQHBhcmFtIHNwYXJzZVZhbHVlcyBBIDAtRCBvciAxLUQgVGVuc29yLiBWYWx1ZXNcbiAqIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCByb3cgb2Ygc3BhcnNlSW5kaWNlcywgb3IgYSBzY2FsYXIgdmFsdWUgdG8gYmUgdXNlZCBmb3JcbiAqIGFsbCBzcGFyc2UgaW5kaWNlcy5cbiAqIEBwYXJhbSBvdXRwdXRTaGFwZSBTaGFwZSBvZiB0aGUgZGVuc2Ugb3V0cHV0IHRlbnNvci4gVGhlIHR5cGUgaXMgaW5mZXJyZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFNjYWxhci4gVmFsdWUgdG8gc2V0IGZvciBpbmRpY2VzIG5vdCBzcGVjaWZpZWQgaW5cbiAqIHNwYXJzZUluZGljZXMuIERlZmF1bHRzIHRvIHplcm8uXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbid9XG4gKi9cbmZ1bmN0aW9uIHNwYXJzZVRvRGVuc2VfPFIgZXh0ZW5kcyBSYW5rPihcbiAgICBzcGFyc2VJbmRpY2VzOiBUZW5zb3J8VGVuc29yTGlrZSwgc3BhcnNlVmFsdWVzOiBUZW5zb3J8VGVuc29yTGlrZSxcbiAgICBvdXRwdXRTaGFwZTogU2hhcGVNYXBbUl0sIGRlZmF1bHRWYWx1ZTogU2NhbGFyfFNjYWxhckxpa2UgPSAwKTogVGVuc29yPFI+IHtcbiAgYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9ucyhvdXRwdXRTaGFwZSk7XG5cbiAgY29uc3QgJHNwYXJzZUluZGljZXMgPVxuICAgICAgY29udmVydFRvVGVuc29yKHNwYXJzZUluZGljZXMsICdzcGFyc2VJbmRpY2VzJywgJ3NwYXJzZVRvRGVuc2UnLCAnaW50MzInKTtcbiAgY29uc3QgJHNwYXJzZVZhbHVlcyA9IGNvbnZlcnRUb1RlbnNvcihcbiAgICAgIHNwYXJzZVZhbHVlcywgJ3NwYXJzZVZhbHVlcycsICdzcGFyc2VUb0RlbnNlJywgJ3N0cmluZ19vcl9udW1lcmljJyk7XG4gIGNvbnN0ICRkZWZhdWx0VmFsdWUgPSBjb252ZXJ0VG9UZW5zb3IoXG4gICAgICBkZWZhdWx0VmFsdWUsICdkZWZhdWx0VmFsdWUnLCAnc3BhcnNlVG9EZW5zZScsICRzcGFyc2VWYWx1ZXMuZHR5cGUpO1xuXG4gIHNwYXJzZV90b19kZW5zZS52YWxpZGF0ZUlucHV0KFxuICAgICAgJHNwYXJzZUluZGljZXMsICRzcGFyc2VWYWx1ZXMsIG91dHB1dFNoYXBlLCAkZGVmYXVsdFZhbHVlKTtcblxuICBjb25zdCBpbnB1dHM6IFNwYXJzZVRvRGVuc2VJbnB1dHMgPSB7XG4gICAgc3BhcnNlSW5kaWNlczogJHNwYXJzZUluZGljZXMsXG4gICAgc3BhcnNlVmFsdWVzOiAkc3BhcnNlVmFsdWVzLFxuICAgIGRlZmF1bHRWYWx1ZTogJGRlZmF1bHRWYWx1ZVxuICB9O1xuXG4gIGNvbnN0IGF0dHJzOiBTcGFyc2VUb0RlbnNlQXR0cnMgPSB7b3V0cHV0U2hhcGV9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgU3BhcnNlVG9EZW5zZSwgaW5wdXRzIGFzIHt9IGFzIE5hbWVkVGVuc29yTWFwLFxuICAgICAgYXR0cnMgYXMge30gYXMgTmFtZWRBdHRyTWFwKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNwYXJzZVRvRGVuc2UgPSBvcCh7c3BhcnNlVG9EZW5zZV99KTtcbiJdfQ==