/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { Tile } from '../kernel_names';
import { convertToTensor } from '../tensor_util_env';
import { assertNonNegativeIntegerDimensions } from '../util_base';
import { clone } from './clone';
import { op } from './operation';
import { reshape } from './reshape';
/**
 * Broadcast an array to a compatible shape NumPy-style.
 *
 * The tensor's shape is compared to the broadcast shape from end to beginning.
 * Ones are prepended to the tensor's shape until it has the same length as
 * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is
 * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then
 * the input tensor is tiled N times along that axis (using tf.tile).
 *
 * @param input The tensor that is to be broadcasted.
 * @param shape The input is to be broadcast to this shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function broadcastTo_(x, shape) {
    let input = convertToTensor(x, 'broadcastTo', 'x');
    const xShape = input.shape;
    assertNonNegativeIntegerDimensions(shape);
    if (shape.length < input.rank) {
        throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);
    }
    if (shape.length > input.rank) {
        const newShape = input.shape.slice();
        while (newShape.length < shape.length) {
            newShape.unshift(1);
        }
        input = reshape(input, newShape);
    }
    const inputShape = input.shape;
    const reps = Array.from(shape);
    for (let i = shape.length - 1; i >= 0; i--) {
        if (inputShape[i] === shape[i]) {
            reps[i] = 1;
        }
        else if (input.shape[i] !== 1) {
            throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
        }
    }
    const axes = reps.map((n, i) => n > 1 ? i : -1).filter(i => i >= 0);
    if (axes.length === 0) {
        return clone(input);
    }
    // TODO call broadcastTo kernel directly once backends implement broadcstTo
    const inputs = { x: input };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
}
export const broadcastTo = op({ broadcastTo_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvYWRjYXN0X3RvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvYnJvYWRjYXN0X3RvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakMsT0FBTyxFQUFDLElBQUksRUFBd0IsTUFBTSxpQkFBaUIsQ0FBQztBQUk1RCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFbkQsT0FBTyxFQUFDLGtDQUFrQyxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRWhFLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDOUIsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMvQixPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRWxDOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxTQUFTLFlBQVksQ0FDakIsQ0FBb0IsRUFBRSxLQUFrQjtJQUMxQyxJQUFJLEtBQUssR0FBRyxlQUFlLENBQUMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNuRCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBRTNCLGtDQUFrQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTFDLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFO1FBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLEtBQUssQ0FBQyxNQUFNLGlCQUN2RCxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztLQUNwQjtJQUVELElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFO1FBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckMsT0FBTyxRQUFRLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDckMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQjtRQUNELEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ2xDO0lBRUQsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUMvQixNQUFNLElBQUksR0FBYSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pDLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNiO2FBQU0sSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUNYLG1CQUFtQixNQUFNLDZCQUE2QixLQUFLLElBQUksQ0FBQyxDQUFDO1NBQ3RFO0tBQ0Y7SUFDRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUVwRSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBYyxDQUFDO0tBQ2xDO0lBRUQsMkVBQTJFO0lBQzNFLE1BQU0sTUFBTSxHQUFlLEVBQUMsQ0FBQyxFQUFFLEtBQUssRUFBQyxDQUFDO0lBQ3RDLE1BQU0sS0FBSyxHQUFjLEVBQUMsSUFBSSxFQUFDLENBQUM7SUFDaEMsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUNuQixJQUFJLEVBQUUsTUFBOEIsRUFBRSxLQUFnQyxDQUFDLENBQUM7QUFDOUUsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsRUFBQyxZQUFZLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vZW5naW5lJztcbmltcG9ydCB7VGlsZSwgVGlsZUF0dHJzLCBUaWxlSW5wdXRzfSBmcm9tICcuLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtOYW1lZEF0dHJNYXB9IGZyb20gJy4uL2tlcm5lbF9yZWdpc3RyeSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7UmFuaywgU2hhcGVNYXAsIFRlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7YXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9uc30gZnJvbSAnLi4vdXRpbF9iYXNlJztcblxuaW1wb3J0IHtjbG9uZX0gZnJvbSAnLi9jbG9uZSc7XG5pbXBvcnQge29wfSBmcm9tICcuL29wZXJhdGlvbic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vcmVzaGFwZSc7XG5cbi8qKlxuICogQnJvYWRjYXN0IGFuIGFycmF5IHRvIGEgY29tcGF0aWJsZSBzaGFwZSBOdW1QeS1zdHlsZS5cbiAqXG4gKiBUaGUgdGVuc29yJ3Mgc2hhcGUgaXMgY29tcGFyZWQgdG8gdGhlIGJyb2FkY2FzdCBzaGFwZSBmcm9tIGVuZCB0byBiZWdpbm5pbmcuXG4gKiBPbmVzIGFyZSBwcmVwZW5kZWQgdG8gdGhlIHRlbnNvcidzIHNoYXBlIHVudGlsIGl0IGhhcyB0aGUgc2FtZSBsZW5ndGggYXNcbiAqIHRoZSBicm9hZGNhc3Qgc2hhcGUuIElmIGlucHV0LnNoYXBlW2ldPT1zaGFwZVtpXSwgdGhlIChpKzEpLXRoIGF4aXMgaXNcbiAqIGFscmVhZHkgYnJvYWRjYXN0LWNvbXBhdGlibGUuIElmIGlucHV0LnNoYXBlW2ldPT0xIGFuZCBzaGFwZVtpXT09TiwgdGhlblxuICogdGhlIGlucHV0IHRlbnNvciBpcyB0aWxlZCBOIHRpbWVzIGFsb25nIHRoYXQgYXhpcyAodXNpbmcgdGYudGlsZSkuXG4gKlxuICogQHBhcmFtIGlucHV0IFRoZSB0ZW5zb3IgdGhhdCBpcyB0byBiZSBicm9hZGNhc3RlZC5cbiAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgaXMgdG8gYmUgYnJvYWRjYXN0IHRvIHRoaXMgc2hhcGUuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnVHJhbnNmb3JtYXRpb25zJ31cbiAqL1xuZnVuY3Rpb24gYnJvYWRjYXN0VG9fPFIgZXh0ZW5kcyBSYW5rPihcbiAgICB4OiBUZW5zb3J8VGVuc29yTGlrZSwgc2hhcGU6IFNoYXBlTWFwW1JdKTogVGVuc29yPFI+IHtcbiAgbGV0IGlucHV0ID0gY29udmVydFRvVGVuc29yKHgsICdicm9hZGNhc3RUbycsICd4Jyk7XG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0LnNoYXBlO1xuXG4gIGFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnMoc2hhcGUpO1xuXG4gIGlmIChzaGFwZS5sZW5ndGggPCBpbnB1dC5yYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBicm9hZGNhc3RUbygpOiBzaGFwZS5sZW5ndGg9JHtzaGFwZS5sZW5ndGh9IDwgaW5wdXQucmFuaz0ke1xuICAgICAgICBpbnB1dC5yYW5rfS5gKTtcbiAgfVxuXG4gIGlmIChzaGFwZS5sZW5ndGggPiBpbnB1dC5yYW5rKSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSBpbnB1dC5zaGFwZS5zbGljZSgpO1xuICAgIHdoaWxlIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIG5ld1NoYXBlLnVuc2hpZnQoMSk7XG4gICAgfVxuICAgIGlucHV0ID0gcmVzaGFwZShpbnB1dCwgbmV3U2hhcGUpO1xuICB9XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICBjb25zdCByZXBzOiBudW1iZXJbXSA9IEFycmF5LmZyb20oc2hhcGUpO1xuICBmb3IgKGxldCBpID0gc2hhcGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoaW5wdXRTaGFwZVtpXSA9PT0gc2hhcGVbaV0pIHtcbiAgICAgIHJlcHNbaV0gPSAxO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuc2hhcGVbaV0gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgYnJvYWRjYXN0VG8oKTogWyR7eFNoYXBlfV0gY2Fubm90IGJlIGJyb2FkY2FzdCB0byBbJHtzaGFwZX1dLmApO1xuICAgIH1cbiAgfVxuICBjb25zdCBheGVzID0gcmVwcy5tYXAoKG4sIGkpID0+IG4gPiAxID8gaSA6IC0xKS5maWx0ZXIoaSA9PiBpID49IDApO1xuXG4gIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjbG9uZShpbnB1dCkgYXMgVGVuc29yPFI+O1xuICB9XG5cbiAgLy8gVE9ETyBjYWxsIGJyb2FkY2FzdFRvIGtlcm5lbCBkaXJlY3RseSBvbmNlIGJhY2tlbmRzIGltcGxlbWVudCBicm9hZGNzdFRvXG4gIGNvbnN0IGlucHV0czogVGlsZUlucHV0cyA9IHt4OiBpbnB1dH07XG4gIGNvbnN0IGF0dHJzOiBUaWxlQXR0cnMgPSB7cmVwc307XG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgVGlsZSwgaW5wdXRzIGFzIHt9IGFzIE5hbWVkVGVuc29yTWFwLCBhdHRycyBhcyB1bmtub3duIGFzIE5hbWVkQXR0ck1hcCk7XG59XG5cbmV4cG9ydCBjb25zdCBicm9hZGNhc3RUbyA9IG9wKHticm9hZGNhc3RUb199KTtcbiJdfQ==