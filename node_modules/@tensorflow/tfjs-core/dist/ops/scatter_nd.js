/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { ScatterNd } from '../kernel_names';
import { convertToTensor } from '../tensor_util_env';
import { assertNonNegativeIntegerDimensions } from '../util_base';
import { op } from './operation';
import * as scatter_nd_util from './scatter_nd_util';
/**
 * Creates a new tensor by applying sparse updates to individual
 * values or slices within a zero tensor of the given shape tensor according to
 * indices. This operator is the inverse of the `tf.gatherND` operator which
 * extracts values or slices from a given tensor.
 *
 * ```js
 * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');
 * const updates = tf.tensor1d([9, 10, 11, 12]);
 * const shape = [8];
 * tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]
 * ```
 *
 * @param indices The tensor contains the indices into the output tensor.
 * @param updates The tensor contains the value for the indices.
 * @param shape: The shape of the output tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}
 */
function scatterND_(indices, updates, shape) {
    assertNonNegativeIntegerDimensions(shape);
    const $indices = convertToTensor(indices, 'indices', 'scatterND', 'int32');
    const $updates = convertToTensor(updates, 'updates', 'scatterND');
    scatter_nd_util.validateInput($updates, $indices, shape);
    const inputs = { indices: $indices, updates: $updates };
    const attrs = { shape };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return ENGINE.runKernel(ScatterNd, inputs, attrs);
}
export const scatterND = op({ scatterND_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl9uZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NjYXR0ZXJfbmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsU0FBUyxFQUFrQyxNQUFNLGlCQUFpQixDQUFDO0FBSTNFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEUsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMvQixPQUFPLEtBQUssZUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBRXJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkc7QUFDSCxTQUFTLFVBQVUsQ0FDZixPQUEwQixFQUFFLE9BQTBCLEVBQ3RELEtBQWtCO0lBQ3BCLGtDQUFrQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLE1BQU0sUUFBUSxHQUFHLGVBQWUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRSxNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNsRSxlQUFlLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFekQsTUFBTSxNQUFNLEdBQW9CLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFDLENBQUM7SUFDdkUsTUFBTSxLQUFLLEdBQW1CLEVBQUMsS0FBSyxFQUFDLENBQUM7SUFFdEMsMERBQTBEO0lBQzFELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FDWixTQUFTLEVBQUUsTUFBOEIsRUFDekMsS0FBMkIsQ0FBYyxDQUFDO0FBQ3ZELENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUMsVUFBVSxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4uL2VuZ2luZSc7XG5pbXBvcnQge1NjYXR0ZXJOZCwgU2NhdHRlck5kQXR0cnMsIFNjYXR0ZXJOZElucHV0c30gZnJvbSAnLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7TmFtZWRBdHRyTWFwfSBmcm9tICcuLi9rZXJuZWxfcmVnaXN0cnknO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1JhbmssIFNoYXBlTWFwLCBUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2Fzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnN9IGZyb20gJy4uL3V0aWxfYmFzZSc7XG5cbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcbmltcG9ydCAqIGFzIHNjYXR0ZXJfbmRfdXRpbCBmcm9tICcuL3NjYXR0ZXJfbmRfdXRpbCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0ZW5zb3IgYnkgYXBwbHlpbmcgc3BhcnNlIHVwZGF0ZXMgdG8gaW5kaXZpZHVhbFxuICogdmFsdWVzIG9yIHNsaWNlcyB3aXRoaW4gYSB6ZXJvIHRlbnNvciBvZiB0aGUgZ2l2ZW4gc2hhcGUgdGVuc29yIGFjY29yZGluZyB0b1xuICogaW5kaWNlcy4gVGhpcyBvcGVyYXRvciBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgYHRmLmdhdGhlck5EYCBvcGVyYXRvciB3aGljaFxuICogZXh0cmFjdHMgdmFsdWVzIG9yIHNsaWNlcyBmcm9tIGEgZ2l2ZW4gdGVuc29yLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBpbmRpY2VzID0gdGYudGVuc29yMmQoWzQsIDMsIDEsIDddLCBbNCwgMV0sICdpbnQzMicpO1xuICogY29uc3QgdXBkYXRlcyA9IHRmLnRlbnNvcjFkKFs5LCAxMCwgMTEsIDEyXSk7XG4gKiBjb25zdCBzaGFwZSA9IFs4XTtcbiAqIHRmLnNjYXR0ZXJORChpbmRpY2VzLCB1cGRhdGVzLCBzaGFwZSkucHJpbnQoKSAvL1swLCAxMSwgMCwgMTAsIDksIDAsIDAsIDEyXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluZGljZXMgVGhlIHRlbnNvciBjb250YWlucyB0aGUgaW5kaWNlcyBpbnRvIHRoZSBvdXRwdXQgdGVuc29yLlxuICogQHBhcmFtIHVwZGF0ZXMgVGhlIHRlbnNvciBjb250YWlucyB0aGUgdmFsdWUgZm9yIHRoZSBpbmRpY2VzLlxuICogQHBhcmFtIHNoYXBlOiBUaGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3IuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZyd9XG4gKi9cbmZ1bmN0aW9uIHNjYXR0ZXJORF88UiBleHRlbmRzIFJhbms+KFxuICAgIGluZGljZXM6IFRlbnNvcnxUZW5zb3JMaWtlLCB1cGRhdGVzOiBUZW5zb3J8VGVuc29yTGlrZSxcbiAgICBzaGFwZTogU2hhcGVNYXBbUl0pOiBUZW5zb3I8Uj4ge1xuICBhc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zKHNoYXBlKTtcbiAgY29uc3QgJGluZGljZXMgPSBjb252ZXJ0VG9UZW5zb3IoaW5kaWNlcywgJ2luZGljZXMnLCAnc2NhdHRlck5EJywgJ2ludDMyJyk7XG4gIGNvbnN0ICR1cGRhdGVzID0gY29udmVydFRvVGVuc29yKHVwZGF0ZXMsICd1cGRhdGVzJywgJ3NjYXR0ZXJORCcpO1xuICBzY2F0dGVyX25kX3V0aWwudmFsaWRhdGVJbnB1dCgkdXBkYXRlcywgJGluZGljZXMsIHNoYXBlKTtcblxuICBjb25zdCBpbnB1dHM6IFNjYXR0ZXJOZElucHV0cyA9IHtpbmRpY2VzOiAkaW5kaWNlcywgdXBkYXRlczogJHVwZGF0ZXN9O1xuICBjb25zdCBhdHRyczogU2NhdHRlck5kQXR0cnMgPSB7c2hhcGV9O1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgcmV0dXJuIEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICAgICAgICAgU2NhdHRlck5kLCBpbnB1dHMgYXMge30gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgYXR0cnMgYXMge30gYXMgTmFtZWRBdHRyTWFwKSBhcyBUZW5zb3I8Uj47XG59XG5cbmV4cG9ydCBjb25zdCBzY2F0dGVyTkQgPSBvcCh7c2NhdHRlck5EX30pO1xuIl19